<html><head>
<meta charset="UTF-8">

<link rel="stylesheet" href="https://raw.githack.com/opencoca/system7.css/main/style.css" />

  
</head>
<body contenteditable="false">

  <title contenteditable="false">HTML is truly open, brutalist html quine â€“ it's what it is</title> 
  <aside contenteditable="false">Title's are supposed to be in the head but browsers don't care.</aside>

  
    <h1 contenteditable="false">This page is a truly open, brutalist html quine...</h1>
    
    <nav contenteditable="false">
      <a href="data:text, To save enable javascript." onclick="saveDOMAsHTML();return false;" contenteditable="false">Save</a>
      <a href="data:text, To edit enable javascript." onclick="toggleAllTextEditable();return false;" contenteditable="false">Edit</a>
    </nav>

    <p contenteditable="false">
      I love to tweak and hack technology in creative ways.
      <br>
      We don't need to break things. 
      <br>
      Let's focus on bending the rules without breaking the rules.</p>

    <p contenteditable="false">I've always loved creating things. As a child I started first with 
      basic, hypercard, Pascal and VB. As I got older moving to php, python, and creating some 
      amazing things like <a href="https://etsy.com/" contenteditable="false">Etsy</a>. This project is inspired by my 
      reflecting on life and reading GÃ¶del, Escher, Bach and most importantly talking with friends 
      and family.</p>

    <p contenteditable="false">The code inspiration <a href="https://github.com/secretGeek/" contenteditable="false">secretGeek</a> 
      and <a href="https://github.com/calroc" contenteditable="false">my close friend Calroc</a>.
    </p>

    <p contenteditable="false">The Computer Science world of&nbsp; code is filled with examples of amazing people stretching the rules, blowing past expectations. People using technology in new and fabulous ways.<br>I love the concept of&nbsp;<a href="http://wiki.secretgeek.net/quine" contenteditable="false">quines </a>. Quines are programs
      which output their own source code.</p>
      
    <p contenteditable="false">If code is life, life is a Quine! As we build new things...they build more.</p>


    <blockquote contenteditable="false">
      Another common theme in Brutalist designs is the exposure of the
      building's functions.
    </blockquote>

    <p contenteditable="false">
      ...the tendency to <strong contenteditable="false">make the internal external</strong>, and reveal
      the secrets of the building, in a somehow.... brutally beautiful -<em contenteditable="false">brutaful</em> way.
    </p>

    <p contenteditable="false">
      A similarly intriguing idea which has fallen into disuse is the idea of
      <a href="https://en.wikipedia.org/wiki/Naked_objects" contenteditable="false">naked objects</a>,
      wherein:
    </p>

    <blockquote contenteditable="false">
      The user interface should be a direct representation 
      of the domain objects.
    </blockquote>

    <p contenteditable="false">
      Putting all this together I decided to make this: a truly naked, brutalist html
      page; a page that is itself a quine; a page that is a<em contenteditable="false">brutaful quine.</em></p>

    <p contenteditable="false">
      How to view<a href="view-source:#This won't work on it's own." contenteditable="false">the source</a>
      of this page? prefix the url with "view-source:" and you'll see the source of this page. Infact you
      can do this on any page. 
    </p>

    <h2 contenteditable="false">How it works.</h2>

    <p contenteditable="false">
      Did you know that the rules of html and css allow you to make
      <strong contenteditable="false">every</strong> element visible, even elements like 'title' or
      'style' or 'script', that are normally hidden from view? <br>Those are just
      elements like any other.<br>You can expose them <strong contenteditable="false">all</strong> like so:
    </p>

    <style contenteditable="false">
      * { display:block; }
    </style>

    <p contenteditable="false">
      With that snippet of code (which is <strong contenteditable="false">not</strong> a snippet of
      code, but an <strong contenteditable="false">actual</strong> style block itself!) you can now see
      every element of this page, including that style block, the html and title
      tags, etc.
    </p>

    <p contenteditable="false">
      It does have one downside: every element on the page is now a "block"
      element, even some which should be "inline", such as "code" and "anchor"
      elements. We can correct this like so:
    </p>

    <style contenteditable="false">
      a,code,em,strong {display:inline}
    </style>

    <p contenteditable="false">
      To give the code a more 'view source' feel, I've also applied
      <code contenteditable="false">monospace</code> fonts, and a generally simple and consistent style
      to all elements, using a "*" selector, like so:
    </p>

    <style contenteditable="false">
      *{ font-family:Monospace; margin:1.5em 0; padding:0; text-decoration:none}
    </style>

    <p contenteditable="false">So far I've put style declarations all on one line, because ordinary
      html refuses to treat line breaks as "br" tags. But there is a way
      to make line-breaks display as line-breaks, and that is with this
      piece of styling:
    </p>

    <style contenteditable="false">
      style, blockquote, script {
        white-space: pre;
      }
    </style>

    <h2 contenteditable="false">Make the internal external.</h2>

    <p contenteditable="false">The next trick is to make the internal external. We can start by 
      ensuring that the tags themselves, such as paragraph tags, are 
      exposed in their stark, brutal, beauty:
    </p>

    <style contenteditable="false">
      p::before {
        content:'<p>'
      }
      p::after {
        content:'</p>'
      }
    </style>

    <p contenteditable="false">That works for "p" elements, but do we need to have custom styling for
      <strong contenteditable="false">every</strong> element? If there was a way to output the "name" of
      a tag in html, then we could reduce all of the necessary style rules above
      to something like:
    </p>

    <blockquote contenteditable="false">*::before { '&lt;' name() '&gt;' }</blockquote>

    <p contenteditable="false">And...</p>

    <blockquote contenteditable="false">*::after { '&lt;\/' name() '&gt;' }</blockquote>

    <p contenteditable="false">But alas there is no "name()" function (yet!). So we are forced to
      generate a chunk of style information like this ðŸ‘‡</p>

    <details contenteditable="false">
  <summary><p contenteditable="false">It's a lot of repetitive code so I wrapped it in a details element. Feel free to click read all the lines of repetitive yet essential style code...
    </p></summary>

    <style contenteditable="false">

      html::before {content:'<html>'}
      html::after {content:'</html>'}
      head::before {content:'<head>'}
      head::after {content:'</head>'}
      title::before {content:'<title>'}
      title::after {content:'</title>'}
      body::before {content:'<body>'}
      body::after {content:'</body>'}
      h1::before {content:'<h1>'}
      h1::after {content:'</h1>'}
      h2::before {content:'<h2>'}
      h2::after {content:'</h2>'}
      p::before {content:'<p>'}
      p::after {content:'</p>'}
      pre::before {content:'<pre>'}
      pre::after {content:'</pre>'}
      code::before {content:'<code>'}
      code::after {content:'</code>'}
      a::before {content:'<a>'}
      a::after {content:'</a>'}
      img::before {content: '<img>'}
      aside::before {content:'<aside>'}
      aside::after {content:'</aside>'}
      blockquote::before {content:'<blockquote>'}
      blockquote::after {content:'</blockquote>'}
      em::before {content:'<em>'}
      em::after {content:'</em>'}
      strong::before {content:'<strong>'}
      strong::after {content:'</strong>'}
      div::before {content:'<div>'}
      div::after {content:'</div>'}
      article::before {content:'<article>'}
      article::after {content:'</article>'}
      nav::before {content:'<nav>'}
      nav::after {content:'</nav>'}
      ul::before {content:'<ul>'}
      ul::after {content:'</ul>'}
      li::before {content:'<li>'}
      li::after {content:'</li>'}
      ol::before {content:'<ol>'}
      ol::after {content:'</ol>'}
      span::before {content:'<span>'}
      span::after {content:'</span>'}
      summary::before {content:'<summary>'}
      summary::after {content:'</summary>'}
      details::before {content:'<details>'}
      details::after {content:'</details>'}
    </style></details>

    <p contenteditable="false">Let's also make it so that whenever over a summary tag our cursor is a pointer and we'll also indent thing by 4 chars.
    </p>

    <style contenteditable="false">
      summary {cursor:pointer;
                margin-left:4ch}
    </style>

    <p contenteditable="false">Some elements are a little trickier because they have attributes. Consider
      for example the "anchor" which often has a <code contenteditable="false">href</code> attribute. We
      <em contenteditable="false">need</em> that attribute to be visible, including its value. This is
      done like so:
    </p>

    <style contenteditable="false">
      a[href]::before {content: "<a href='" attr(href) "'>"}
    </style>

    <p contenteditable="false">
      The <code contenteditable="false">attr()</code> function, see
      <a href="https://developer.mozilla.org/docs/Web/CSS/attr" contenteditable="false">mozilla docs</a>
      is a nifty trick, "supported" since CSS 2.
    </p>

    <p contenteditable="false">A surprisingly troublesome set of tags are any that don't close. br and img for example. While we can get our &lt;br&gt;s to be processed by adding empty content this isn't the case with images at this time.</p>
      <style contenteditable="false">
      br {
          content: "";
          margin: 0
      }

      br::after {
          content: "<br>";
          margin-top: -1em;
          white-space: pre;
      }
      
      /* TODO ...figure out how to have imgs work ;) */
      img { margin: auto !important; 
            content: "" !important}

      img::before {
          content: "<img src='" attr(src) "'>"
      }
      img::after {}

    </style><p contenteditable="true">
      <a href="https://en.wikipedia.org/wiki/File:The_Earth_seen_from_Apollo_17.jpg" class="mw-file-description" style="text-decoration-line: underline; color: rgb(51, 102, 204); background-image: none; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; overflow-wrap: break-word; display: block; position: relative; border: 0px; font-family: sans-serif; font-size: 14px; text-align: center;" contenteditable="false">
      <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/The_Earth_seen_from_Apollo_17.jpg/220px-The_Earth_seen_from_Apollo_17.jpg" decoding="async" width="220" height="220">
      <br>The Earth seen from Apollo as an example img</a></p><p contenteditable="false">Another other element that is special is "style" itself, which has to
      include an escape character to avoid being taken literally. Her'e that along with a little tweak to keep our closing style tags from being indented.</p>

    <style contenteditable="false">
      style::before {content:'<style>'}
      style::after  {content:'<\/style>'; 
                     margin-left: -3ch}
      /* While we are at it let's have a little fun and style our style elements */
      style {
        background: hsl(270, 63.5%, 50%, 20% );
        font-family: Geneva_9;
        font-size: 1.4em;
      }
    </style>

    <aside contenteditable="false">I like to think that may be a parser bug created by browser developers who
      did not suspect that people would engage in such an atrocity.
    </aside>

    <p contenteditable="false">Along with this we expose any script tags and make sure that their
      content is pre-formated.
    </p>

    <style contenteditable="false">
      script{white-space: pre-wrap;}
      script::before {content:'<script>'}
      script::after  {content:'</script>'; 
                      margin-left: -4ch}
    </style>

    <p contenteditable="false">&nbsp;On top of this if we don't do a little more tweaking the head the style and script tags are exposed, but they look messy. Their closing tags are indented 
      when unlike in our body they shouldn't be. So we just need to add a little style to the head element to fix this.</p>

    <style contenteditable="false">
      head script::after, head style::after {margin-left: 0}
      /* Let's reuse our a href technique to expose what 
         scripts are sourced in our page */
      script[src]::before {content: "<script='" attr(src) "'>"}
      /* Let's reuse our a href technique to expose what 
         styles are sourced in our page */
      link[href]::before {content: "<link='" attr(href) "'>"}
    </style>
    


    <p contenteditable="false">
      Let us simplify navigation formating by also applying our pre-formatting to our 
      nav element. At the same time we can expose positioning of it and we'll make sure that the nav element's closing tag is not indented.</p>

    <style contenteditable="false">
      nav{white-space: pre;
          position: sticky;
          top:1;
          background: white}
      nav::after  {margin-left: -4ch}
      nav a[href]::before{content: '<a>'}
    </style>

    <p contenteditable="false">To reduce the visual weight of the before and after pseudo
      elements we can give them a soft purple color and a low weight font:</p>

    <style contenteditable="false">
      *::before,*::after {
        color:hsl(270, 63.5%, 50%, 60% );
        font-weight:100;
        font-size:1.0em
      }
    </style>

    <p contenteditable="false">
      Finally, as I believe brutalist design, even when applied to truly
      naked brutal html quines, is about function, not about deliberate
      ugliness, I'd like to apply these humble styles that improve the
      readability of this brutiful stack.
    </p>

    <style contenteditable="false">
      html {
        max-width:80ch;
        padding:2ch;
        margin:auto;
        color:hsl(270, 0%, 0%, 80%) !important;
        font-size:1.4em;
      }
    </style>

    <p contenteditable="false">
      ...they're derived from<a href="https://jrl.ninja/etc/1/" contenteditable="false">jrl.ninja's amazing 58 bytes of css to look great nearly everywhere"</a>.
    </p>

    <p contenteditable="false">
      One last thing. Although this idea has bounced around in my head for a
      decade, the thing that reminded me to pipe it into a file was seeing this
      piece of "Code as Art" from Geoff Huntley:
      <a href="https://noyaml.com/" contenteditable="false">no yaml</a>. Bring back the world weird web.
    </p>

    <p contenteditable="false">Kind regards</p>
    <p contenteditable="false">p.s.
      <a href="." contenteditable="false">source code here</a>
    </p>
      

    <script contenteditable="false">
      // Function to save the DOM as an HTML file
      function saveDOMAsHTML() {
        // Turn off editing so we don't lock it on
        turnOffAllTextEditable();
        //get our current title and make it filesafe
        const fileSafeTitle = () => document.title.replace(/[^\w\s]/g, '')
                                        .trim().replace(/\s+/g, '-');
        const htmlContent = document.documentElement.outerHTML;
        // Create a Blob with the HTML content
        const blob = new Blob([htmlContent], { type: 'text/html' });
        // Create a temporary URL to the Blob
        const url = URL.createObjectURL(blob);
        // Create a link element to trigger the download
        const a = document.createElement('a');
        a.href = url;
        a.download = fileSafeTitle() +'.html';
        // Trigger a click event on the link to start the download
        a.click();
        // Clean up by revoking the Blob URL
        URL.revokeObjectURL(url);
      }

      let isEditable = false;

      function turnOffAllTextEditable() {
        const textNodes = getTextNodes(document.body);
        textNodes.forEach((node) => {
          node.parentElement.contentEditable = false;
        });
        isEditable = false;
      }

      function toggleAllTextEditable() {
        const textNodes = getTextNodes(document.body);
        isEditable = !isEditable;
        textNodes.forEach((node) => {
          node.parentElement.contentEditable = isEditable;
        });
      }
      function getTextNodes(element) {
        const textNodes = [];
        function extractTextNodes(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            textNodes.push(node);
          } else {
            for (const childNode of node.childNodes) {
              extractTextNodes(childNode);
            }
          }
        }
        extractTextNodes(element);
        return textNodes;
      }
    </script>

</body></html>