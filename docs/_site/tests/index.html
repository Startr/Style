<html><head>
<meta charset="UTF-8">

<style id="webmakerstyle">

</style>
<script type="module" integrity="sha512-7Y25+FX/kRUbZEHtQBOSLffzofBxz8ABQErLAVpGkfzactkpJU5wtTmhIfIZeTw7VHg1JeTIC5kHkzPq7LqR1w==" src="/.11ty/reload-client.js"></script></head>
<body contenteditable="false">

  
    <title contenteditable="false">An html doc that is truly open, brutalist html quine â€“ its what is is
    </title>
  

  
    <h1 contenteditable="false">This page is a truly open, brutalist html quine...</h1>
    
    <nav contenteditable="false">
      <a href="data:text, To save you need javascript. Please turn it on." onclick="saveDOMAsHTML();return false;" contenteditable="false">Save</a>
      <a href="data:text, To edit you need javascript. Please turn it on." onclick="toggleAllTextEditable();return false;" contenteditable="false">Edit</a>
    </nav>

    <p contenteditable="false">
      One of my favorite things is to tweak and hack technology in creative ways.&nbsp;<br><br><a href="https://en.wikipedia.org/wiki/File:Hotel_Paradiso_FilmPoster.jpeg" class="mw-file-description" style="text-decoration-line: underline; color: rgb(51, 102, 204); background: none rgb(248, 249, 250); overflow-wrap: break-word; font-family: sans-serif; font-size: 12.32px; text-align: center;"><br></a>Bending the rules without breaking the rules.</p>

    <p contenteditable="false">&nbsp;I've always loved creating things first with basic, hypercard, and then moving to php and python. This specific project is inspired by secretGeeks, html quine along with their hobby project&nbsp;<a href="https://github.com/secretGeek/dod" contenteditable="false">DOS-on-dope</a>, a working
      Ruby-on-rails parody, billed as
      <em contenteditable="false">the last batch-file based MVC framework you'll ever need</em>. Allong with&nbsp;<a href="http://www.secretgeek.net/console_log" contenteditable="false">a console.log() adventure</a>
      in which you played an old school console-adventure-game from inside the
      chrome developer tools.</p>

    <p contenteditable="false">
      The world of coding is filled with examples of people
      stretching the rules, blowing past expectations. People usimg technology in new&nbsp; and creative ways. In particular I love the concept of&nbsp;<a href="http://wiki.secretgeek.net/quine" contenteditable="false">quines</a>. Quines are programs
      which output their own source code.&nbsp;</p><p contenteditable="false">If code is life, life is a Quine! We build new things and they build more.&nbsp;</p>

    <p contenteditable="false">
      A different but related topic I appreciate is&nbsp;<a href="https://en.wikipedia.org/wiki/Brutalist_architecture" contenteditable="false">Brutalist Architecture</a>, in particular, this overlooked aspect:
    </p>

    <blockquote contenteditable="false">
      Another common theme in Brutalist designs is the exposure of the
      building's functions.
    </blockquote>

    <p contenteditable="false">
      ...the tendency to <strong contenteditable="false">make the internal external</strong>, and reveal
      the secrets of the building, in a somehow.... brutally beautiful -<em contenteditable="false">brutaful</em> way.
    </p>

    <p contenteditable="false">
      A similarly intriguing idea which has fallen into disuse is the idea of
      <a href="https://en.wikipedia.org/wiki/Naked_objects" contenteditable="false">naked objects</a>,
      wherein:
    </p>

    <blockquote contenteditable="false">
      The user interface should be a direct representation 
      of the domain objects.
    </blockquote>

    <p contenteditable="false">
      Putting all this together I decided to make this: a truly naked, brutalist html
      page; a page that is itself a quine; a page that is a&nbsp;<em contenteditable="false">brutaful quine.</em></p>

    <p contenteditable="false">
      Viewing<br>TODO Fix this url<a href="view-source:#This won't work as 
      a link but should if you prefix this page's url with view-source." contenteditable="false">the source</a>
      of this page should reveal a page identical to the page you are now
      seeing. Nothing is hidden. It's a true "What you see is what you get."
    </p>

    <h2 contenteditable="false">How it works.</h2>

    <p contenteditable="false">
      Did you know that the rules of html and css allow you to make
      <strong contenteditable="false">every</strong> element visible, even elements like 'title' or
      'style' or 'script', that are normally hidden from view? <br>Those are just
      elements like any other.<br>&nbsp;You can expose them <strong contenteditable="false">all</strong> like so:
    </p>

    <style contenteditable="false">
      * { display:block; }
    </style>

    <p contenteditable="false">
      With that snippet of code (which is <strong contenteditable="false">not</strong> a snippet of
      code, but an <strong contenteditable="false">actual</strong> style block itself!) you can now see
      every element of this page, including that style block, the html and title
      tags, etc.
    </p>

    <p contenteditable="false">
      It does have one downside: every element on the page is now a "block"
      element, even some which should be "inline", such as "code" and "anchor"
      elements. We can correct this like so:
    </p>

    <style contenteditable="false">
      
    </style>

    <style contenteditable="false">
      a,code,em,strong {display:inline}
    </style>

    <p contenteditable="false">
      To give the code a more 'view source' feel, I've also applied
      <code contenteditable="false">monospace</code> fonts, and a generally simple and consistent style
      to all elements, using a "*" selector, like so:
    </p>

    <style contenteditable="false">
      *{ font-family:Monospace; margin:1.5em 0; padding:0; text-decoration:none}
    </style>

    <p contenteditable="false">
      So far I've put style declarations all on one line, because ordinary
      html refuses to treat line breaks as "br" tags. But there is a way
      to make line-breaks display as line-breaks, and that is with this
      piece of styling:
    </p>

    <style contenteditable="false">
      style, blockquote, script {
        white-space: pre;
      }
    </style>

    <h2 contenteditable="false">Make the internal external.</h2>

    <p contenteditable="false">
      The next trick is to make the internal external. We can start by 
      ensuring that the tags themselves, such as paragraph tags, are 
      exposed in their stark, brutal, beauty:
    </p>

    <style contenteditable="false">
      p::before {
        content:'<p>'
      }
      p::after {
        content:'</p>'
      }
    </style>

    <p contenteditable="false">
      That works for "p" elements, but do we need to have custom styling for
      <strong contenteditable="false">every</strong> element? If there was a way to output the "name" of
      a tag in html, then we could reduce all of the necessary style rules above
      to something like:
    </p>

    <blockquote contenteditable="false">*::before { '&lt;' name() '&gt;' }</blockquote>

    <p contenteditable="false">And...</p>

    <blockquote contenteditable="false">*::after { '&lt;\/' name() '&gt;' }</blockquote>

    <p contenteditable="false">
      But alas there is no "name()" function (yet!). So we are forced to
      generate a chunk of style information like this (via
      <a href="https://nimbletext.com/Live/1105905186/" contenteditable="false">NimbleText</a> of
      course)
    </p>

    <details>
  <summary><p contenteditable="false">
      Please scroll happily past the next N# lines of repetitive yet essential style code...
    </p></summary>

    <style contenteditable="false">

      html::before {content:'<html>'}
      html::after {content:'</html>'}
      head::before {content:'<head>'}
      head::after {content:'</head>'}
      title::before {content:'<title>'}
      title::after {content:'</title>'}
      body::before {content:'<body>'}
      body::after {content:'</body>'}
      h1::before {content:'<h1>'}
      h1::after {content:'</h1>'}
      h2::before {content:'<h2>'}
      h2::after {content:'</h2>'}
      p::before {content:'<p>'}
      p::after {content:'</p>'}
      pre::before {content:'<pre>'}
      pre::after {content:'</pre>'}
      code::before {content:'<code>'}
      code::after {content:'</code>'}
      a::before {content:'<a>'}
      a::after {content:'</a>'}
      img::before {content: '<img>'}
      aside::before {content:'<aside>'}
      aside::after {content:'</aside>'}
      blockquote::before {content:'<blockquote>'}
      blockquote::after {content:'</blockquote>'}
      em::before {content:'<em>'}
      em::after {content:'</em>'}
      strong::before {content:'<strong>'}
      strong::after {content:'</strong>'}
      div::before {content:'<div>'}
      div::after {content:'</div>'}
      article::before {content:'<article>'}
      article::after {content:'</article>'}
      nav::before {content:'<nav>'}
      nav::after {content:'</nav>'}
      ul::before {content:'<ul>'}
      ul::after {content:'</ul>'}
      li::before {content:'<li>'}
      li::after {content:'</li>'}
      ol::before {content:'<ol>'}
      ol::after {content:'</ol>'}
      span::before {content:'<span>'}
      span::after {content:'</span>'}
      summary::before {content:'<summary>'}
      summary::after {content:'</summary>'}
      details::before {content:'<details>'}
      details::after {content:'</details>'}
    </style></details>

    <p>
      Let's also make it so that whenever over a summary tag our cursor is a pointer and we'll also indent thing by 4 chars.
    </p>

    <style contenteditable="false">
      summary {cursor:pointer;
                margin-left:4ch}
    </style>

    <p contenteditable="false">
      Some elements are a little trickier because they have attributes. Consider
      for example the "anchor" which often has a <code contenteditable="false">href</code> attribute. We
      <em contenteditable="false">need</em> that attribute to be visible, including its value. This is
      done like so:
    </p>

    <style contenteditable="false">
      a[href]::before {content: "<a href='" attr(href) "'>"}
    </style>

    <p contenteditable="false">
      The <code contenteditable="false">attr()</code> function, see
      <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/attr" contenteditable="false">mozilla docs</a>
      is a nifty trick, "supported" since CSS 2.
    </p>

    <p contenteditable="false">A surprisingly troublesome set of tags are any that don't close. br and img for example. While we can get br's to be processed by adding empty content this isn't the case with images at this time.</p>
      <style contenteditable="false">
      br {
          content: "";
          margin: 0
      }

      br::after {
          content: "<br>";
          margin-top: -1em;
          white-space: pre;
      }
      
      /* TODO figure out how to have imgs work ;) */
      img { margin: auto !important; 
            content: "" !important}

      img::before {
          content: "<img src='" attr(src) "'>"
      }
      img::after {}

    </style><p contenteditable="true"><a href="https://en.wikipedia.org/wiki/File:The_Earth_seen_from_Apollo_17.jpg" class="mw-file-description" style="text-decoration-line: underline; color: rgb(51, 102, 204); background-image: none; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; overflow-wrap: break-word; display: block; position: relative; border: 0px; font-family: sans-serif; font-size: 14px; text-align: center;" contenteditable="false"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/The_Earth_seen_from_Apollo_17.jpg/220px-The_Earth_seen_from_Apollo_17.jpg" decoding="async" width="220" height="220" class="mw-file-element" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/9/97/The_Earth_seen_from_Apollo_17.jpg/330px-The_Earth_seen_from_Apollo_17.jpg 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/9/97/The_Earth_seen_from_Apollo_17.jpg/440px-The_Earth_seen_from_Apollo_17.jpg 2x" data-file-width="3000" data-file-height="3002" style="border: 1px solid rgb(200, 204, 209); vertical-align: middle; margin: 3px; background: rgb(255, 255, 255);"><br>The Earth seen from Apollo as an example img</a></p><p contenteditable="false">Another other style that is special is "style" itself, which has to
      include an escape character to avoid being taken literally. Along with a little tweak to keep our closing style tags from being indented.</p>

    <style contenteditable="false">
      style::before {content:'<style>'}
      style::after  {content:'<\/style>'; 
                     margin-left: -4ch}
    </style>

    <aside contenteditable="false">I like to think that may be a parser bug created by browser developers who
      did not suspect that people would engage in such an atrocity.
    </aside>

    <p contenteditable="false">Along with this we expose any script tags and make sure that their
      content is preformated.
    </p>

    <style contenteditable="false">
      script{white-space: pre;}
      script::before {content:'<script>'}
      script::after  {content:'</script>'; 
                      margin-left: -4ch}</span>
    </style>

    <p contenteditable="false">
      Let us simplify navigation formating by also applying pre-fomating to our nav element.
    </p>

    <style contenteditable="false">
      nav{white-space: pre;}
    </style>

    <p contenteditable="false">&nbsp;To reduce the visual weight of the before and after pseudo
      elements we can give them a soft purple color and a low weight font:
    </p>

    <style contenteditable="false">
      *::before,*::after {
        color:hsl(270, 63.5%, 50%, 60% );
        font-weight:100;
        font-size:1.0em
      }
    </style>

    <aside contenteditable="false">
      A different though similar thing I wanted to do was to make a
      "markdown.css" file that displays html as markdown. Fortunately I found
      that some other twisted person had<br><a href="https://mrcoles.com/demo/markdown-css/" contenteditable="false">already done exactly that.</a>
      Nice work Mr Coles.
    </aside>

    <p contenteditable="false">
      Finally, because I believe brutalist design, even when applied to truly
      naked brutal html quines, is about function, not about deliberate
      ugliness, I'd like to apply these humble styles that improve the
      readability of this brutiful missive.
    </p>

    <style contenteditable="false">
      html {
        max-width:50em;
        padding:2ch;
        margin:auto;
        color:hsl(270, 0%, 0%, 80%) !important;
        font-size:1.4em;
      }
    </style>

    <p contenteditable="false">
      ...they're derived from&nbsp;<a href="https://jrl.ninja/etc/1/" contenteditable="false">jrl.ninja's amazing 58 bytes of css to look great nearly everywhere"</a>.
    </p>

    <p contenteditable="false">
      One last thing. Although this idea has bounced around in my head for a
      decade, the thing that reminded me to pipe it into a file was seeing this
      piece of "Code as Art" from Geoff Huntley:
      <a href="https://noyaml.com/" contenteditable="false">no yaml</a>. Bring back the world weird web.
    </p>

    <p contenteditable="false">Kind regards</p>
    <p contenteditable="false">&nbsp;p.s.
      <a href="." contenteditable="false">source code here</a>
    </p>
      

    <script contenteditable="false">
      // Function to save the DOM as an HTML file
      function saveDOMAsHTML() {
        // Turn off editing so we don't lock it on
        turnOffAllTextEditable();
        //get our current title and make it filesafe
        const fileSafeTitle = () => document.title.replace(/[^\w\s]/g, '')
                                        .trim().replace(/\s+/g, '-');
        const htmlContent = document.documentElement.outerHTML;
        // Create a Blob with the HTML content
        const blob = new Blob([htmlContent], { type: 'text/html' });
        // Create a temporary URL to the Blob
        const url = URL.createObjectURL(blob);
        // Create a link element to trigger the download
        const a = document.createElement('a');
        a.href = url;
        a.download = fileSafeTitle() +'.html';
        // Trigger a click event on the link to start the download
        a.click();
        // Clean up by revoking the Blob URL
        URL.revokeObjectURL(url);
      }

      let isEditable = false;

      function turnOffAllTextEditable() {
        const textNodes = getTextNodes(document.body);
        textNodes.forEach((node) => {
          node.parentElement.contentEditable = false;
        });
        isEditable = false;
      }

      function toggleAllTextEditable() {
        const textNodes = getTextNodes(document.body);
        isEditable = !isEditable;
        textNodes.forEach((node) => {
          node.parentElement.contentEditable = isEditable;
        });
      }
      function getTextNodes(element) {
        const textNodes = [];
        function extractTextNodes(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            textNodes.push(node);
          } else {
            for (const childNode of node.childNodes) {
              extractTextNodes(childNode);
            }
          }
        }
        extractTextNodes(element);
        return textNodes;
      }
    </script>
  



<script src="https://webmaker.app/app/lib/screenlog.js"></script>


</body></html>