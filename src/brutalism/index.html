<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="https://raw.githack.com/opencoca/system7.css/main/style.css">

    <title>A Brutalist HTML Quine – It is what it is</title>

  </head>
  <body>

    <h1 id="quine">This page is a truly open, brutalist Quine, an HTML Quine</h1>

    <nav>
      <a href="#how_it_works">How</a>
      <a id="save" 
         href="data:text, To save enable javascript." 
         onclick="saveDOMAsHTML();return false;">Save</a>
      <a id="edit" 
         href="data:text, To edit enable javascript." 
         onclick="toggleAllTextEditable();return false;">Edit</a>
      <a id="toggleDrag" 
         href="data:text, To drag enable javascript." 
         onclick="return false" 
         style="--d: none; --d-sm: inline;">Drag</a>

    </nav>

    <p>I've always loved creating things. As a child, it was block and paint, but then I started first with Basic, Hypercard, C, Pascal and VB. As I got older, I moved to PHP, then Python, and created some amazing things like <a href="https://etsy.com/">Etsy</a>&nbsp;and Startr. These days I focus on&nbsp;<a href="https://robotinacan.com/">Robots </a>&nbsp;and other projects.</p>
    <p>I love to create things that are useful and beautiful. Things that inspire others to create are the most powerful and rewarding to build.<br>I love to create things that are fun and silly. Things that are weird and wonderful I love the most.<br>While I love creating beautiful things, I enjoy keeping them exposed and raw. Brutally functional things often feel best to me.</p>
    <p>
      I love to tweak and hack technology in creative ways.
      <br>
      We don't need to break things to make new things, and we don't need to reinvent the wheel, either. So many amazing things exist to build on.<br>
      Let's focus on bending the rules without breaking the rules.</p>

    <p>To these ends, this project is inspired by my reflecting on life and reading Gödel, Escher, Bach, and, most importantly, talking with friends and family. The code was inspired by&nbsp;<a href="https://github.com/secretGeek/">secretGeek</a>  and <a href="https://sr.ht/~sforman">my close friend Simon Forman</a>.
    </p>

    <p>The computer science world of code is filled with examples of amazing people stretching the rules and blowing past expectations. People use technology in new and fabulous ways every day.</p>

    <p>I love the creativity that sparks further change. Quines are programs
      which output their source code. Used properly, they can spark all kinds of possibilities. If code is life, life is a Quine! As we build new things...they build more!</p>

    <blockquote>
      A common theme in brutalism is the exposure of the functions of artifacts.
    </blockquote>

    <p>Exposing how things work lets us&nbsp;<strong>make the internal external </strong>, and reveal the secrets of what we build, in somehow.... brutally beautiful -<em>brutaful</em> ways.
    </p>

    <p>&nbsp;A similar approach when building with code is the idea of
      <a href="https://en.wikipedia.org/wiki/Naked_objects">naked objects</a>. <br>When working with naked objects:
    </p>

    <blockquote>
     Objects represent concepts
     in their purest form, 
     without additional 
     layers or abstractions.

     The goal of naked objects
     is simplicity and
     transparency. 
    </blockquote>
    <p>
      How to view<a href="view-source:#This won't work on it's own.">the source</a>
      of this page? prefix the url with "view-source:" and you'll see the source of this page. Infact you
      can do this on any page. 
    </p>
    <p>The "naked objects" concept was introduced by a software developer named Martin Fowler. He proposed that instead of hiding the true nature of objects behind layers of abstractions and interfaces, we should instead reveal the objects in their "naked" form.</p>
    <p>
      Putting all this together, I decided to make this: a truly naked, brutalist html
      page; a page itself a quine; a page that is a<em>brutaful quine.</em>
    </p>
    <p>This means exposing the objects in their purest, fundamental form without unnecessary embellishments or distractions. Basically, it's a way of thinking about software design that prioritizes simplicity and transparency over layers of indirection.</p>

    <a id="how_it_works"></a>
    <h2>How it works.</h2>

    <p>
      Did you know that the rules of HTML (the building blocks of the Web) and CSS(the styling system of the Web) allow us to make
      <strong>every</strong>&nbsp;Web page element visible, even special HTML elements like 'title', 'style' and 'script', elements that are normally hidden from view? <br>Those are just
      elements like any other.<br>You can expose&nbsp;<strong>all</strong>&nbsp;of them like so:
    </p>

    <style>
      * {
        display: block;
      }
    </style>

    <p>
      With that snippet of code (which <strong>is not</strong> a snippet of
      code, but an <strong>actual</strong> style block!), you can now see
      every element of this page, including that style block, the HTML and title
      tags, etc.
    </p>

    <aside>
      You might have noticed that we have a little menu at the 👆 top of the page. There is a link to "Edit" the page in that menu. If you click that link, you can edit the page, even the style block above! Don't worry
      if you mess up; you can always refresh the page to get back to the version you last opened.<br>If you want to keep your changes, use the "Save" link and save things to work locally on your computer, tablet, or even phone. (Tell me if you run into any problems).</aside>

    <p>
      Our little style element does have one downside: every element on the page is now a "block"
      element, even some which should be "inline," such as "code" and "anchor"
      elements. We can correct this like so:
    </p>

    <style>
      a,
      code,
      em,
      i,
      strong {
        display: inline;
      }
    </style>

    <p>
      To make it feel more like you are viewing the source, I've also applied
      <code>monospace fonts</code>&nbsp;and a generally simple and consistent style
      to all elements, using a "*" selector, like so:
    </p>

    <style>
      * {
        font-family: Monospace;
        margin: 1.5em 0;
        padding: 0;
        text-decoration: none;
      }
    </style>

    <p>So far, I've put style declarations all on one line because ordinary HTML refuses to treat line breaks as "br" tags. But there is a way
      to make line breaks display as line breaks, and that is with this
      piece of styling:
    </p>

    <style>
      script,
      style {
        white-space: pre;
      }

      /* TODO move these */
      blockquote {
        white-space: pre-wrap;
      }

      p {
        word-break: break-word;
      }
    </style>

    <h2>Make the internal external</h2>

    <p>The next step in making an HTML Quine is to make the internal external. We can start by 
      ensuring that the tags themselves, such as paragraph tags, are 
      exposed in their stark, natural, brutal beauty:
    </p>

    <style>
      /* This is a style comment. Below are special 
         before and after styling for our <p></p>, otherwise 
         known as paragraph elements. */
      p::before {
        content: '<p>';
      }
      p::after {
        content: '</p>';
      }
    </style>

    <p>Adding these special pseudo-elements works for "&lt;p&gt;" elements, but we need to have custom styling for
      <strong>every</strong> element. Pseudo-elements are special keywords that allow us to style specific parts of selected elements.</p>
    <p>We'll need something to add a before and after&nbsp;pseudo-element to each element.If there was a way to output the "name" of
      a tag in HTML, then we could reduce all of the necessary style rules above
      to something like&nbsp;</p>

    <blockquote>
      *::before {'&lt;'name()'&gt;'}
    </blockquote>

    <p>And...</p>

    <blockquote>
      *::after { '&lt;'name()'&gt;' }
    </blockquote>

    <p>But alas there is no "name()" function (yet!). So we are forced to
      generate a chunk of style information like this 👇</p>

    <details>
      <summary>It's a lot of repetitive code, so "click" if you want to read it all.&nbsp;
      </summary>

      <style>

        html::before {
          content: '<html>';
        }
        html::after {
          content: '</html>';
        }
        head::before {
          content: '<head>';
        }
        head::after {
          content: '</head>';
        }
        title::before {
          content: '<title>';
        }
        title::after {
          content: '</title>';
        }
        body::before {
          content: '<body>';
        }
        body::after {
          content: '</body>';
        }
        h1::before {
          content: '<h1>';
        }
        h1::after {
          content: '</h1>';
        }
        h2::before {
          content: '<h2>';
        }
        h2::after {
          content: '</h2>';
        }
        p::before {
          content: '<p>';
        }
        p::after {
          content: '</p>';
        }
        pre::before {
          content: '<pre>';
        }
        pre::after {
          content: '</pre>';
        }
        code::before {
          content: '<code>';
        }
        code::after {
          content: '</code>';
        }
        a::before {
          content: '<a>';
        }
        a::after {
          content: '</a>';
        }
        img::before {
          content: '<img>';
        }
        aside::before {
          content: '<aside>';
        }
        aside::after {
          content: '</aside>';
        }
        blockquote::before {
          content: '<blockquote>';
        }
        blockquote::after {
          content: '</blockquote>';
        }
        em::before {
          content: '<em>';
        }
        em::after {
          content: '</em>';
        }
        strong::before {
          content: '<strong>';
        }
        strong::after {
          content: '</strong>';
        }
        div::before {
          content: '<div>';
        }
        div::after {
          content: '</div>';
        }
        article::before {
          content: '<article>';
        }
        article::after {
          content: '</article>';
        }
        nav::before {
          content: '<nav>';
        }
        nav::after {
          content: '</nav>';
        }
        ul::before {
          content: '<ul>';
        }
        ul::after {
          content: '</ul>';
        }
        li::before {
          content: '<li>';
        }
        li::after {
          content: '</li>';
        }
        ol::before {
          content: '<ol>';
        }
        ol::after {
          content: '</ol>';
        }
        span::before {
          content: '<span>';
        }
        span::after {
          content: '</span>';
        }
        summary::before {
          content: '<summary>';
        }
        summary::after {
          content: '</summary>';
        }
        details::before {
          content: '<details>';
        }
        details::after {
          content: '</details>';
        }
      </style>
    </details>

    <p>Let's also make it so that whenever our cursor is over a summary tag, it is a pointer, and we'll also indent things by 4 characters (4 chars).
    </p>

    <style>
      summary {
        cursor: pointer;
        margin: 1ch 4ch;
      }
    </style>

    <p>Some elements are a little trickier because they have attributes. Attributes are special variables or settings that HTML elements can have. Consider, for example, the &lt;a&gt; or ⚓️ (anchor), which often has a <code>href</code> attribute. We
      <em>need</em> that attribute, including its value, to be visible. This is
      done like so:
    </p>

    <style>
      a[href]::before {
        content: "<a href='" attr(href) "'>";
      }
    </style>

    <p>
      The <code>attr()</code> function, see
      <a href="https://developer.mozilla.org/docs/Web/CSS/attr">mozilla docs</a>
      is a nifty trick, "supported" since CSS 2.
    </p>

    <p>A surprisingly troublesome set of tags are any that don't close. Two examples of these non-closing tags are &lt;br&gt; and &lt;img&gt;. While we can make our &lt;br&gt;s visible(on most browsers) by adding empty content, this isn't the case with images now.</p>
    <style>
      /* This doesn't work on Safari */
      br {
        content: "";
        margin: 0;
      }

      br::after {
        content: "<br>";
        margin-top: -1em;
        white-space: pre;
      }

      /* TODO ...figure out how to have imgs show thier src ;) */

      img::before {
        content: "<img src='" attr(src) "'>";
      }
      img::after {}

      img {
        margin: auto !important;
        image-rendering: crisp-edges;
      }
    </style>
    <p style="--ta:center">
      <img src="me_myself_somma_small.avif" 
        decoding="async" width="" height="" 
        alt="Me, Myself, Somma" loading="lazy" 
        style="display: block; margin: auto;" 
        title="Me, Myself, Somma">
      <br>Me Myself Somma on a good day outside Tokyo.</p>
  </p>
  <p>TODO: Add a more fun yet brutalist image or edit the image so it's more fun.<br></p>
  <p>&nbsp;Another special element is 
      "style" itself, which must include an escape character to avoid 
      being taken literally. Here is the styling code and a little tweak 
      to keep our closing style tags from being indented.</p>

  <style>
    style::before {
      content: '<style>';
    }
    style::after {
      content: '<\/style>';
      margin-left: -3ch;
    }

    /* While we are at it, let's have a little 
         fun and style our style elements, giving
         them a background and a font */
    style {
      background: hsl(270, 63.5%, 50%, 20%);
      font-family: Geneva_9;
      font-size: 1.4em;
      overflow: auto;
    }
  </style>

  <aside>I think the need for escaping the closing tag (e.g. "\/style" instead of "/style") of our style element may be a parser 
      bug. Browser developers might not have predicted that we would engage in the fun we're exploring here.
    </aside>

  <p>Along with this, we will expose any script 
      tags and ensure their
      content is pre-formated.
    </p>

  <style>
    script::before {
      content: '<script>';
    }
    script::after {
      content: '</script>';
      margin-left: -3.1ch;
    }

    /* Let's theme our script elements */
    script {
      background: hsl(210, 63.5%, 50%, 20%);
      font-family: Geneva_9;
      font-size: 1.4em;
      overflow: auto;
    }
  </style>

  <p>If we don't do a little more tweaking to our document's head element, our style and script tags are  
      exposed but look messy. Their closing tag will be indented, unlike in our body. So we need to 
      add a little more style to the head element to fix this.</p>

  <style>
    head script::after,
    head style::after {
      margin-left: 0;
    }

    /* We can reuse our a href technique to expose what 
         scripts are sourced in the page */

    script[src]::before {
      content: "<script='" attr(src) "'>";
    }

    /*  Oh, and we need links for external resources */

    link[href]::before {
      content: "<link='" attr(href) "'>";
    }
    link {
      overflow: auto;
    }
  </style>

  <a id="how_nav_works"></a>

  <p>
      You might be wondering about that menu at the top of our
      page.&nbsp;</p>
  <p>Here's how it works. First, we use the "position: sticky" style to allow it to stick to the top of our page once we scroll to it. With it stuck to the top of our viewport, it stays there unless we scroll above where we loaded it (just after we opened our body element).&nbsp;</p>
  <p>As we want things to stay tidy in our menu, we'll hide the hrefs from our anchors.</p>

  <style>
    nav {
      position: sticky;
      top: 1;
      background: white;
      padding: 0.2em;
      text-align: center;
    }
    /* This will hide the hrefs of our navigation links */
    nav a[href]::before {
      content: '<a>';
    }

    /*. At the same time, we'll deal with our block quotes */
    blockquote::after {
      margin-left: -4ch;
    }
  </style>

  <p>To reduce the visual weight of the before and after pseudo-elements, we can give them a soft purple color and mostly hide them until we focus on them.:</p>

  <style>
    *::after,
    *::before {
      color: hsl(270, 63.5%, 50%, 20%);
      line-height: 0.7;
      transition: all 0.3s ease;
    }
    *:hover::after,
    *:hover::before,
    a::after,
    a::before {
      color: hsl(270, 63.5%, 50%, 80%);
    }
  </style>

  <p>
      Finally, I believe brutalist design, even when applied to truly
      naked brutal HTML Quines, is about function, not deliberate
      ugliness; I'd like to apply two humble style sets that improve the
      readability of this "brutiful" stack.
    </p>

  <style>
    /* 101 Startr Bytes of Style */
    html {
      max-width: 80ch;
      padding: 2ch;
      margin: auto;
      color: hsl(270, 0%, 0%, 90%) !important;
      font-size: 1.4em;
    }

    /* Hover over link, Style and Script elements to enjoy */
    link,
    script,
    style {
      transition: all 0.3s ease;
      opacity: 20%;
      max-height: 24rem;
    }
    script:hover,
    style:hover {
      opacity: 100%;

    }
    /* Fix for nav flicker  */
    nav {
      z-index: 1000;
    }
  </style>

  <p>&nbsp;The first is our 101 Startr Bytes of Style. We apply it as the base style to our whole html to give things a clean, modern feel. The second is a little bit of transition magic. It tones down the look of elements we wouldn't normally see unless we hover over them.</p>

  <p>
      One last thing. Although this idea has bounced around in my head for a
      decade, the thing that reminded me to pipe it into a file was seeing this
      piece of "Code as Art" from Geoff Huntley:
      <a href="https://noyaml.com/">no yaml</a>. Bring back the world's weird web.
    </p>

  <p>Kind regards</p>
  <p>
    <i>P.S.</i>&nbsp;Our saving and editing features are powered by JavaScript. The following script is used to save the DOM as an HTML file and to toggle all text nodes' "contentEditable" attribute.<br>
      The attribute "contentEditable" is a special one that allows us to edit 
      the text of any element.
    </p>
  <details open="">

    <summary>The script is as follows👇. We've wrapped it in a details element for brevity. </summary>

    <script>
      // Function to delete script elements with src="/.11ty/reload-client.js"
      ///This is here to help with local 11nty dev

      function deleteReloadClientScripts() {
        document
          .querySelectorAll('script[src="/.11ty/reload-client.js"]')
          .forEach(function (item) {
            item.remove()
          })
      }

      // Function to save the DOM as an HTML file
      function saveDOMAsHTML() {
        // Turn off editing so we don't lock it on
        turnOffAllTextEditable();

        // Turn off all draggable elements
        turnOffDraggableElements();

        // Call the function to delete the script elements
        deleteReloadClientScripts();

        // Get the current title and make it filesafe
        const fileSafeTitle = () => document
          .title
          .replace(/[^\w\s]/g, '')
          .trim()
          .replace(/\s+/g, '-');
        const htmlContent = document.documentElement.outerHTML;

        // Create a Blob with the HTML content
        const blob = new Blob([htmlContent], {type: 'text/html'});

        // Create a temporary URL to the Blob
        const url = URL.createObjectURL(blob);

        // Create a link element to trigger the download
        const a = document.createElement('a');
        a.href = url;
        a.download = fileSafeTitle() + '.html';

        // Trigger a click event on the link to start the download
        a.click();

        // Clean up by revoking the Blob URL
        URL.revokeObjectURL(url);
      }

      let isEditable = false;

      function turnOffAllTextEditable() {
        const textNodes = getTextNodes(document);
        textNodes.forEach((node) => {
          node
            .parentElement
            .removeAttribute('contentEditable');
        });
        isEditable = false;
        // set text of anchor #edit to "Stop Editing" to reflect state
        document
          .getElementById('edit')
          .innerText = 'Edit';
      }

      function toggleAllTextEditable() {
        const textNodes = getTextNodes(document);
        isEditable = !isEditable;
        // set text of anchor #edit to "Edit" or "Stop Editing" to reflect state
        textNodes.forEach((node) => {
          node.parentElement.contentEditable = isEditable;
        });
        document
          .getElementById('edit')
          .innerText = isEditable
            ? 'Stop Editing'
            : 'Edit';
      }
      function getTextNodes(element) {
        const textNodes = [];
        function extractTextNodes(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            textNodes.push(node);
          } else {
            for (const childNode of node.childNodes) {
              extractTextNodes(childNode);
            }
          }
        }
        extractTextNodes(element);
        return textNodes;
      }

      document
        .body
        .addEventListener('paste', function (e) {
          e.preventDefault();

          // Get the pasted text
          const clipboardData = e.clipboardData || window.clipboardData;
          const pastedText = clipboardData.getData('text/plain');

          // Filter out properties that don't start with "--"
          const filteredText = pastedText.replace(/(--[\w-]+:[^;]+;)/g, '');

          // Insert the filtered text into the body's contentEditable
          document.execCommand('insertText', false, filteredText);
        });

      // Define a debounce function
      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      }

      // Drag and Drop
      var isDragMode = false;
      var draggedElement = null;
      var placeholder = document.createElement('section');
      var lastTarget = null;

      placeholder.style.border = '3px dashed #0099FF'; // Placeholder styling
      placeholder.style.height = '1px'; // Set a default height, adjust as needed
      // set a negative margin to compensate for the additional height
      placeholder.style.marginBottom = '-1.6rem';

      function toggleDraggableElements() {
        isDragMode = !isDragMode;
        var elementsToToggle = document.querySelectorAll('img, p, ol, ul, li, blockquote, h1, h2, h3, h4, h5, h6, pre, code, a, em, strong, div, article, summary, details, nav, aside, span, script, style');
        elementsToToggle.forEach(function (element) {
          element.setAttribute('draggable', isDragMode);
        });
      }

      function turnOffDraggableElements() {

        isDragMode = false;
        // set text of anchor #toggleDrag to "Drag" to reflect state
        document
          .getElementById('toggleDrag')
          .innerText = 'Drag';
        //remove .removeAttribute('draggable') for any elements that have it
        // select by attribute
        var elementsToToggle = document.querySelectorAll('[draggable]');
        elementsToToggle.forEach(function (element) {
          element.removeAttribute('draggable');
        });
      }

      function handleDragStart(event) {
        if (!isDragMode) {
          event.preventDefault();
          return;
        }
        draggedElement = event.target;
      }

      function handleDragOver(event) {
        if (!isDragMode || !draggedElement) {
          event.preventDefault();
          return;
        }
        event.preventDefault();
        var dropTarget = event.target;

        // Get the previous sibling of the drop target
        var previousSibling = dropTarget.previousElementSibling;

        // Only move the placeholder if it's not already in the correct position
        if (previousSibling !== placeholder) {
          dropTarget.insertAdjacentElement('beforebegin', placeholder);
        }
      }

      function handleDrop(event) {
        if (!isDragMode || !draggedElement) {
          event.preventDefault();
          return;
        }
        event.preventDefault();

        requestAnimationFrame(() => {
          placeholder.replaceWith(draggedElement);
          draggedElement = null; // Reset the draggedElement variable
        });
      }

      function handleMouseOver(event) {
        if (isDragMode) {
          //event.target.style.outline = '2px solid #0099FF';  Blue outline
        }
      }

      function handleMouseOut(event) {
        if (isDragMode) {
          event.target.style.outline = ''; // Remove outline
        }
      }

      var toggleDragButton = document.getElementById('toggleDrag');
      toggleDragButton.addEventListener('click', function () {
        toggleDraggableElements();
        toggleDragButton.textContent = isDragMode
          ? 'Stop Drag'
          : 'Drag';
      });

      document.addEventListener('dragstart', handleDragStart);
      document.addEventListener('dragover', handleDragOver);
      document.addEventListener('drop', handleDrop);
      document.addEventListener('mouseover', handleMouseOver);
      document.addEventListener('mouseout', handleMouseOut);
    </script>
  </details>

  <p>
    <i>P.P.S.</i>&nbsp;If you want to see the source of this page, prefix the URL with "view-source:" and you'll see the source. You can do this on any page!</p>


    <h2 style="--ta: center" id="discover">Discover limitless possibilities</h2>
    <p style="--ta: center">
      Explore our lab of resources and experiment with the endless possibilities of Startr Style.
    </p>
    <p style="--ta: center">
      <a style="--cur:pointer" onclick="window.location.href = '/brutalism/'">Brutalism</a> |
      <a style="--cur:pointer" onclick="window.location.href = '/modernism/'">Modernism</a> |
      <a onclick="null" style="--c: lightgrey">Minimalism</a> |
      <a onclick="null" style="--c: lightgrey">Skeuomorphism</a> |
      <a onclick="null" style="--c: lightgrey">Neumorphism</a> |
      <a onclick="null" style="--c: lightgrey">More</a>
    </p>
</body>
</html>