<html><head>
<meta charset="UTF-8">

<style>

</style>

<script type="module" integrity="sha512-7Y25+FX/kRUbZEHtQBOSLffzofBxz8ABQErLAVpGkfzactkpJU5wtTmhIfIZeTw7VHg1JeTIC5kHkzPq7LqR1w==" src="/.11ty/reload-client.js"></script>

  
</head>
<body contenteditable="false">

  

  <title contenteditable="false">HTML is truly open, brutalist html quine – it's what it is</title> 
  <aside>Title's are supposed to be in the head but browsers don't care.</aside>

  
    <h1 contenteditable="false">This page is a truly open, brutalist html quine...</h1>
    
    <nav contenteditable="false">
      <a href="data:text, To save enable javascript." onclick="saveDOMAsHTML();return false;" contenteditable="false">Save</a>
      <a href="data:text, To edit enable javascript." onclick="toggleAllTextEditable();return false;" contenteditable="false">Edit</a>
    </nav>

    <p contenteditable="false">
      One of my favorite things is to tweak and hack technology in creative ways.
      <br>
      We don't need to break things. 
      <br>
      Let's focus on bending the rules without breaking the rules.</p>

    <p contenteditable="false">I've always loved creating things. As a child I started first with 
      basic, hypercard, Pascal and VB. As I got older moving to php, python, and creating some 
      amazing things like <a href="https://etsy.com/">Etsy</a>. This project is inspired by my 
      reflecting on life and reading Gödel, Escher, Bach and most importantly talking with friends 
      and family.</a></p>

    <p>
      Code insipration 
      from<a href="https://github.com/secretGeek/">secretGeek</a> 
      and <a href="https://github.com/calroc">my close friend calroc</a>.
    </p>

    <p contenteditable="false">
      The world of code is filled with examples of people stretching the rules, blowing past expectations. People usimg technology in new and creative ways. In particular I love the concept of<a href="http://wiki.secretgeek.net/quine" contenteditable="false"> quines </a>. Quines are programs
      which output their own source code.</p>
      
    <p contenteditable="false">If code is life, life is a Quine! We build new things and they build more.</p>


    <blockquote contenteditable="false">
      Another common theme in Brutalist designs is the exposure of the
      building's functions.
    </blockquote>

    <p contenteditable="false">
      ...the tendency to <strong contenteditable="false">make the internal external</strong>, and reveal
      the secrets of the building, in a somehow.... brutally beautiful -<em contenteditable="false">brutaful</em> way.
    </p>

    <p contenteditable="false">
      A similarly intriguing idea which has fallen into disuse is the idea of
      <a href="https://en.wikipedia.org/wiki/Naked_objects" contenteditable="false">naked objects</a>,
      wherein:
    </p>

    <blockquote contenteditable="false">
      The user interface should be a direct representation 
      of the domain objects.
    </blockquote>

    <p contenteditable="false">
      Putting all this together I decided to make this: a truly naked, brutalist html
      page; a page that is itself a quine; a page that is a<em contenteditable="false">brutaful quine.</em></p>

    <p contenteditable="false">
      How to view<a href="view-source:#This won't work on it's own." contenteditable="false">the source</a>
      of this page? prefix the url with "view-source:" and you'll see the source of this page. Infact you
      can do this on any page. 
    </p>

    <h2 contenteditable="false">How it works.</h2>

    <p contenteditable="false">
      Did you know that the rules of html and css allow you to make
      <strong contenteditable="false">every</strong> element visible, even elements like 'title' or
      'style' or 'script', that are normally hidden from view? <br>Those are just
      elements like any other.<br>You can expose them <strong contenteditable="false">all</strong> like so:
    </p>

    <style contenteditable="false">
      * { display:block; }
    </style>

    <p contenteditable="false">
      With that snippet of code (which is <strong contenteditable="false">not</strong> a snippet of
      code, but an <strong contenteditable="false">actual</strong> style block itself!) you can now see
      every element of this page, including that style block, the html and title
      tags, etc.
    </p>

    <p contenteditable="false">
      It does have one downside: every element on the page is now a "block"
      element, even some which should be "inline", such as "code" and "anchor"
      elements. We can correct this like so:
    </p>

    <style contenteditable="false">
      
    </style>

    <style contenteditable="false">
      a,code,em,strong {display:inline}
    </style>

    <p contenteditable="false">
      To give the code a more 'view source' feel, I've also applied
      <code contenteditable="false">monospace</code> fonts, and a generally simple and consistent style
      to all elements, using a "*" selector, like so:
    </p>

    <style contenteditable="false">
      *{ font-family:Monospace; margin:1.5em 0; padding:0; text-decoration:none}
    </style>

    <p contenteditable="false">
      So far I've put style declarations all on one line, because ordinary
      html refuses to treat line breaks as "br" tags. But there is a way
      to make line-breaks display as line-breaks, and that is with this
      piece of styling:
    </p>

    <style contenteditable="false">
      style, blockquote, script {
        white-space: pre;
      }
    </style>

    <h2 contenteditable="false">Make the internal external.</h2>

    <p contenteditable="false">
      The next trick is to make the internal external. We can start by 
      ensuring that the tags themselves, such as paragraph tags, are 
      exposed in their stark, brutal, beauty:
    </p>

    <style contenteditable="false">
      p::before {
        content:'<p>'
      }
      p::after {
        content:'</p>'
      }
    </style>

    <p contenteditable="false">
      That works for "p" elements, but do we need to have custom styling for
      <strong contenteditable="false">every</strong> element? If there was a way to output the "name" of
      a tag in html, then we could reduce all of the necessary style rules above
      to something like:
    </p>

    <blockquote contenteditable="false">*::before { '&lt;' name() '&gt;' }</blockquote>

    <p contenteditable="false">And...</p>

    <blockquote contenteditable="false">*::after { '&lt;\/' name() '&gt;' }</blockquote>

    <p contenteditable="false">
      But alas there is no "name()" function (yet!). So we are forced to
      generate a chunk of style information like this (via
      <a href="https://nimbletext.com/Live/1105905186/" contenteditable="false">NimbleText</a> of
      course)
    </p>

    <details>
  <summary><p contenteditable="false">
      Please scroll happily past the next N# lines of repetitive yet essential style code...
    </p></summary>

    <style contenteditable="false">

      html::before {content:'<html>'}
      html::after {content:'</html>'}
      head::before {content:'<head>'}
      head::after {content:'</head>'}
      title::before {content:'<title>'}
      title::after {content:'</title>'}
      body::before {content:'<body>'}
      body::after {content:'</body>'}
      h1::before {content:'<h1>'}
      h1::after {content:'</h1>'}
      h2::before {content:'<h2>'}
      h2::after {content:'</h2>'}
      p::before {content:'<p>'}
      p::after {content:'</p>'}
      pre::before {content:'<pre>'}
      pre::after {content:'</pre>'}
      code::before {content:'<code>'}
      code::after {content:'</code>'}
      a::before {content:'<a>'}
      a::after {content:'</a>'}
      img::before {content: '<img>'}
      aside::before {content:'<aside>'}
      aside::after {content:'</aside>'}
      blockquote::before {content:'<blockquote>'}
      blockquote::after {content:'</blockquote>'}
      em::before {content:'<em>'}
      em::after {content:'</em>'}
      strong::before {content:'<strong>'}
      strong::after {content:'</strong>'}
      div::before {content:'<div>'}
      div::after {content:'</div>'}
      article::before {content:'<article>'}
      article::after {content:'</article>'}
      nav::before {content:'<nav>'}
      nav::after {content:'</nav>'}
      ul::before {content:'<ul>'}
      ul::after {content:'</ul>'}
      li::before {content:'<li>'}
      li::after {content:'</li>'}
      ol::before {content:'<ol>'}
      ol::after {content:'</ol>'}
      span::before {content:'<span>'}
      span::after {content:'</span>'}
      summary::before {content:'<summary>'}
      summary::after {content:'</summary>'}
      details::before {content:'<details>'}
      details::after {content:'</details>'}
    </style></details>

    <p>
      Let's also make it so that whenever over a summary tag our cursor is a pointer and we'll also indent thing by 4 chars.
    </p>

    <style contenteditable="false">
      summary {cursor:pointer;
                margin-left:4ch}
    </style>

    <p contenteditable="false">
      Some elements are a little trickier because they have attributes. Consider
      for example the "anchor" which often has a <code contenteditable="false">href</code> attribute. We
      <em contenteditable="false">need</em> that attribute to be visible, including its value. This is
      done like so:
    </p>

    <style contenteditable="false">
      a[href]::before {content: "<a href='" attr(href) "'>"}
    </style>

    <p contenteditable="false">
      The <code contenteditable="false">attr()</code> function, see
      <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/attr" contenteditable="false">mozilla docs</a>
      is a nifty trick, "supported" since CSS 2.
    </p>

    <p contenteditable="false">A surprisingly troublesome set of tags are any that don't close. br and img for example. While we can get br's to be processed by adding empty content this isn't the case with images at this time.</p>
      <style contenteditable="false">
      br {
          content: "";
          margin: 0
      }

      br::after {
          content: "<br>";
          margin-top: -1em;
          white-space: pre;
      }
      
      /* TODO figure out how to have imgs work ;) */
      img { margin: auto !important; 
            content: "" !important}

      img::before {
          content: "<img src='" attr(src) "'>"
      }
      img::after {}

    </style><p contenteditable="true"><a href="https://en.wikipedia.org/wiki/File:The_Earth_seen_from_Apollo_17.jpg" class="mw-file-description" style="text-decoration-line: underline; color: rgb(51, 102, 204); background-image: none; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; overflow-wrap: break-word; display: block; position: relative; border: 0px; font-family: sans-serif; font-size: 14px; text-align: center;" contenteditable="false"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/The_Earth_seen_from_Apollo_17.jpg/220px-The_Earth_seen_from_Apollo_17.jpg" decoding="async" width="220" height="220" class="mw-file-element" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/9/97/The_Earth_seen_from_Apollo_17.jpg/330px-The_Earth_seen_from_Apollo_17.jpg 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/9/97/The_Earth_seen_from_Apollo_17.jpg/440px-The_Earth_seen_from_Apollo_17.jpg 2x" data-file-width="3000" data-file-height="3002" style="border: 1px solid rgb(200, 204, 209); vertical-align: middle; margin: 3px; background: rgb(255, 255, 255);"><br>The Earth seen from Apollo as an example img</a></p><p contenteditable="false">Another other style that is special is "style" itself, which has to
      include an escape character to avoid being taken literally. Along with a little tweak to keep our closing style tags from being indented.</p>

    <style contenteditable="false">
      style::before {content:'<style>'}
      style::after  {content:'<\/style>'; 
                     margin-left: -4ch}
    </style>

    <aside contenteditable="false">I like to think that may be a parser bug created by browser developers who
      did not suspect that people would engage in such an atrocity.
    </aside>

    <p contenteditable="false">Along with this we expose any script tags and make sure that their
      content is preformated.
    </p>

    <style contenteditable="false">
      script{white-space: pre;}
      script::before {content:'<script>'}
      script::after  {content:'</script>'; 
                      margin-left: -4ch}
    </style>

    <p>
      In the head the style and script tags are exposed, but they look messy. Thier closing tags are indented 
      when unlike in our body they shouldn't be. So we just need to add a little style to the head element to fix this.
    </p>

    <style>
      head script::after, head style::after {margin-left: 0}
    </style>
    


    <p contenteditable="false">
      Let us simplify navigation formating by also applying pre-fomating to our 
      nav element. At the same time we'll make sure that the nav element's closing tag is not indented.
    </p>

    <style contenteditable="false">
      nav{white-space: pre;}
      nav::after  {margin-left: -4ch}</span>
    </style>

    <p contenteditable="false">To reduce the visual weight of the before and after pseudo
      elements we can give them a soft purple color and a low weight font:
    </p>

    <style contenteditable="false">
      *::before,*::after {
        color:hsl(270, 63.5%, 50%, 60% );
        font-weight:100;
        font-size:1.0em
      }
    </style>

    <aside contenteditable="false">
      A different though similar thing I wanted to do was to make a
      "markdown.css" file that displays html as markdown. Fortunately I found
      that some other twisted person had<br><a href="https://mrcoles.com/demo/markdown-css/" contenteditable="false">already done exactly that.</a>
      Nice work Mr Coles.
    </aside>

    <p contenteditable="false">
      Finally, because I believe brutalist design, even when applied to truly
      naked brutal html quines, is about function, not about deliberate
      ugliness, I'd like to apply these humble styles that improve the
      readability of this brutiful missive.
    </p>

    <style contenteditable="false">
      html {
        max-width:50em;
        padding:2ch;
        margin:auto;
        color:hsl(270, 0%, 0%, 80%) !important;
        font-size:1.4em;
      }
    </style>

    <p contenteditable="false">
      ...they're derived from<a href="https://jrl.ninja/etc/1/" contenteditable="false">jrl.ninja's amazing 58 bytes of css to look great nearly everywhere"</a>.
    </p>

    <p contenteditable="false">
      One last thing. Although this idea has bounced around in my head for a
      decade, the thing that reminded me to pipe it into a file was seeing this
      piece of "Code as Art" from Geoff Huntley:
      <a href="https://noyaml.com/" contenteditable="false">no yaml</a>. Bring back the world weird web.
    </p>

    <p contenteditable="false">Kind regards</p>
    <p contenteditable="false">p.s.
      <a href="." contenteditable="false">source code here</a>
    </p>
      

    <script contenteditable="false">
      // Function to save the DOM as an HTML file
      function saveDOMAsHTML() {
        // Turn off editing so we don't lock it on
        turnOffAllTextEditable();
        //get our current title and make it filesafe
        const fileSafeTitle = () => document.title.replace(/[^\w\s]/g, '')
                                        .trim().replace(/\s+/g, '-');
        const htmlContent = document.documentElement.outerHTML;
        // Create a Blob with the HTML content
        const blob = new Blob([htmlContent], { type: 'text/html' });
        // Create a temporary URL to the Blob
        const url = URL.createObjectURL(blob);
        // Create a link element to trigger the download
        const a = document.createElement('a');
        a.href = url;
        a.download = fileSafeTitle() +'.html';
        // Trigger a click event on the link to start the download
        a.click();
        // Clean up by revoking the Blob URL
        URL.revokeObjectURL(url);
      }

      let isEditable = false;

      function turnOffAllTextEditable() {
        const textNodes = getTextNodes(document.body);
        textNodes.forEach((node) => {
          node.parentElement.contentEditable = false;
        });
        isEditable = false;
      }

      function toggleAllTextEditable() {
        const textNodes = getTextNodes(document.body);
        isEditable = !isEditable;
        textNodes.forEach((node) => {
          node.parentElement.contentEditable = isEditable;
        });
      }
      function getTextNodes(element) {
        const textNodes = [];
        function extractTextNodes(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            textNodes.push(node);
          } else {
            for (const childNode of node.childNodes) {
              extractTextNodes(childNode);
            }
          }
        }
        extractTextNodes(element);
        return textNodes;
      }
    </script>
  



<script src="https://webmaker.app/app/lib/screenlog.js"></script>


</body></html>