<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/style.css" />
    <link rel="stylesheet" href="https://raw.githack.com/opencoca/system7.css/main/style.css" />

    <title>An Open Experimental App, An HTML App&nbsp;</title>
  </head>
  <body>
    <nav>
      <a href="#how_it_works">How</a>
      <a id="save" href="data:text, To save enable javascript." onclick="saveDOMAsHTML();return false;">Save</a>
      <a id="edit" href="data:text, To edit enable javascript." onclick="toggleAllTextEditable();return false;">Edit</a>
      <a
        id="toggleDrag"
        href="data:text, To drag enable javascript."
        onclick="return false"
        style="--d: none; --d-sm: inline"
        >Drag</a
      >
    </nav>

    <h1 id="quine">This page is an open, Experimental app, an HTML app</h1>

    <p>
      As a budding programmer, my journey began with the elemental syntax of languages like Basic and Pascal, gradually
      evolving into more sophisticated realms of Python and SQL. With each line of code I wrote, each interface I
      designed, seemed to gravitate towards a philosophy I could not yet articulate. At first I looked at the hard lines
      and rough textures of brutalism, but there was more than this.
    </p>

    <p>
      The allure of Modernism, with clean simplicity and unwavering focus on function, eventually dawned upon me as a
      beacon of timeless design in a sea of transient trends.
    </p>

    <p style="--ta: center">FORM EVER</p>
    <p style="--ta: center">FOLLOWS</p>
    <p style="--ta: center">FUNCTION</p>
    <p style="--ta: right">- Louis Sullivan, Architect</p>

    <img src="./dither_it_Bauhaus_Dessau_2018.avif" style="--mt: 2em; --mb: 2em; --shadow: 10" />

    <p>
      Modernism transcends the tactile structures, infiltrating the digital architecture of the web. Much like the
      Experimental architects who were pioneers of a movement that celebrated the core function of structures, stripping
      away the superfluous, I too, revel in the pursuit of web designs that are clean, functional, and devoid of
      unnecessary ornamentation. The beauty of a website should emanate from its utility, seamless navigation, and
      intuitive interface that requires no manual to explore.
    </p>

    <p>
      Modernism expresses the real structure that is there in elegant ways. Modernism avoids veneers of unnecessary
      styling, instead focusing on the function of elements. This is similar to brutalism, but with a more refined
      approach to design.
    </p>

    <p>
      Experimental Web Design is not just a design choice; it's a philosophy that echoes the pragmatic beauty of code -
      the underlying grid that orchestrates the dance of pixels on a screen. It's about embracing elegance, minimalist
      color palettes, and the open spaces that breathe between elements. Modernism is grace through the rational use of
      materials - in our case, code, that shapes the user's journey across a digital landscape.
    </p>

    <p>
      As Experimental architecture exposes the bones of a building, celebrating the raw materials and structural
      integrity, Experimental Web Design lays bare the code, grid, and foundational elements – our digital realm.
    </p>

    <p>
      Modernism focuses on crafting experiences that are functional, yet exude an aesthetic charm by virtue of their
      simplicity and ease of use. It's about making the internal external, allowing users to revel in the beauty of
      functionality, to appreciate the 'brutally beautiful', or as I like to coin it, 'brutaful' essence of
      well-designed web interfaces.
    </p>

    <p>
      As we delve deeper into the realms of web development, every project emerges as a canvas waiting for the essence
      of Modernism. Each line of code we type is a tribute to the principle that form should follow function. All that
      we build is part of the narrative that resonates through the virtual halls of the websites we create.
    </p>

    <p>
      The elegance of code lies in its efficiency - its ability to execute function with a brutal honesty, and its
      clarity of purpose – its refusal to cloak the mechanics in frivolous aesthetics. As with Brutalist Web Design,
      true Experimental design builds on this with clean and naked objects.
    </p>

    <p>
      The notion of naked objects in coding resonates deeply with this philosophy. Naked objects are stripping down to
      the bare essentials, revealing the core functionality in a manner that's intuitive and visually coherent. As we
      venture forth in the world of web design, the principles of Modernism guide our fingers, shaping the digital
      edifices we create.
    </p>

    <p>
      Each project is an ode to functionality, a pursuit of an aesthetic minimalism that serves the user, honouring the
      profound simplicity that lies at the heart of Modernism.
    </p>

    <a id="how_it_works"></a>
    <h2>How it works.</h2>

    <p>
      Did you know that the rules of HTML (the building blocks of the Web) and CSS(the styling system of the Web) allow
      us to make
      <strong>every</strong>&nbsp;Web page element visible, even special HTML elements like 'title', 'style' and
      'script', elements that are normally hidden from view? <br />Those are just elements like any other.<br />You can
      expose&nbsp;<strong>all</strong>&nbsp;of them like so:
    </p>

    <style>
      * {
        display: block;
      }
    </style>

    <p>
      With that snippet of code (which <strong>is not</strong> a snippet of code, but an <strong>actual</strong> style
      block!), you can now see every element of this page, including that style block, the HTML and title tags, etc.
    </p>

    <aside>
      You might have noticed that we have a little menu at the 👆 top of the page. There is a link to "Edit" the page in
      that menu. If you click that link, you can edit the page, even the style block above! Don't worry if you mess up;
      you can always refresh the page to get back to the version you last opened.<br />If you want to keep your changes,
      use the "Save" link and save things to work locally on your computer, tablet, or even phone. (Tell me if you run
      into any problems).
    </aside>

    <p>
      To learn how we built our naked objects and to start your journey into the world of "brutaful" web design, please
      visit our website at https://startr.style/brutalism. We believe that this exploration of Modernism and its
      application to web development will inspire you to create digital landscapes that resonate with the timeless
      principles of form following function.
    </p>
    <p>
      With modernism we now add more intentionality to our designs. While with brutalist design we would always expose
      all elements with modernism we accept that there are often times where we don't want to look at raw objects. With
      brutalism we always aim to expose the stone and steel of our structures. With modernism we choose when and where
      to expose elements.
    </p>
    <p style="--bgc: lightseagreen">
      To the end of being intentional with when and how we style our naked elements we'll add a little of our
      Startr.Style. Double click on this paragraph and you will be given the option to specify a background color (a
      --bgc). We've given it the color "lightyellow". Why don't you change it to another one such as, "lightblue",
      "turquoise", or, "lightseagreen".
    </p>

    <p>
      The W3 has a a list of https://www.w3.org/wiki/CSS/Properties/color/keywords. If you get a chance, read all about
      the World Wide Web Consortium (W3C). They develop standards and guidelines to help everyone build The Web. Not
      only do they have a list of color keywords, but five (5) other methods for specifying color values, along with
      many many other details for how to build the web.
    </p>

    <style>
      a,
      code,
      em,
      i,
      strong {
        display: inline;
      }
    </style>

    <p>
      To make it feel more like you are viewing the source, I've also applied
      <code>monospace fonts</code>&nbsp;and a generally simple and consistent style to all elements, using a "*"
      selector, like so:
    </p>

    <style>
      * {
        font-family: Monospace;
        margin: 1.5em 0;
        padding: 0;
        text-decoration: none;
      }
    </style>

    <p>
      So far, I've put style declarations all on one line because ordinary HTML refuses to treat line breaks as "br"
      tags. But there is a way to make line breaks display as line breaks, and that is with this piece of styling:
    </p>

    <style>
      script,
      style {
        white-space: pre;
      }

      /* TODO move these */
      blockquote {
        white-space: pre-wrap;
      }

      p {
        word-break: break-word;
      }
    </style>

    <h2>Make the internal external</h2>

    <p>
      The next step in making an HTML Quine is to make the internal external. We can start by ensuring that the tags
      themselves, such as paragraph tags, are exposed in their stark, natural, brutal beauty:
    </p>

    <style>
      /* This is a style comment. Below are special
         before and after styling for our <p></p>, otherwise
         known as paragraph elements. */
      p::before {
        content: "<p>";
      }
      p::after {
        content: "</p>";
      }
    </style>

    <p>
      Adding these special pseudo-elements works for "&lt;p&gt;" elements, but we need to have custom styling for
      <strong>every</strong> element. Pseudo-elements are special keywords that allow us to style specific parts of
      selected elements.
    </p>
    <p>
      We'll need something to add a before and after&nbsp;pseudo-element to each element.If there was a way to output
      the "name" of a tag in HTML, then we could reduce all of the necessary style rules above to something like&nbsp;
    </p>

    <blockquote>*::before {'&lt;'name()'&gt;'}</blockquote>

    <p>And...</p>

    <blockquote>*::after { '&lt;'name()'&gt;' }</blockquote>

    <p>
      But alas there is no "name()" function (yet!). So we are forced to generate a chunk of style information like this
      👇
    </p>

    <details>
      <summary>It's a lot of repetitive code, so "click" if you want to read it all.&nbsp;</summary>

      <style>
        html::before {
          content: "<html>";
        }
        html::after {
          content: "</html>";
        }
        head::before {
          content: "<head>";
        }
        head::after {
          content: "</head>";
        }
        title::before {
          content: "<title>";
        }
        title::after {
          content: "</title>";
        }
        body::before {
          content: "<body>";
        }
        body::after {
          content: "</body>";
        }
        h1::before {
          content: "<h1>";
        }
        h1::after {
          content: "</h1>";
        }
        h2::before {
          content: "<h2>";
        }
        h2::after {
          content: "</h2>";
        }
        p::before {
          content: "<p>";
        }
        p::after {
          content: "</p>";
        }
        pre::before {
          content: "<pre>";
        }
        pre::after {
          content: "</pre>";
        }
        code::before {
          content: "<code>";
        }
        code::after {
          content: "</code>";
        }
        a::before {
          content: "<a>";
        }
        a::after {
          content: "</a>";
        }
        img::before {
          content: "<img>";
        }
        aside::before {
          content: "<aside>";
        }
        aside::after {
          content: "</aside>";
        }
        blockquote::before {
          content: "<blockquote>";
        }
        blockquote::after {
          content: "</blockquote>";
        }
        em::before {
          content: "<em>";
        }
        em::after {
          content: "</em>";
        }
        strong::before {
          content: "<strong>";
        }
        strong::after {
          content: "</strong>";
        }
        div::before {
          content: "<div>";
        }
        div::after {
          content: "</div>";
        }
        article::before {
          content: "<article>";
        }
        article::after {
          content: "</article>";
        }
        nav::before {
          content: "<nav>";
        }
        nav::after {
          content: "</nav>";
        }
        ul::before {
          content: "<ul>";
        }
        ul::after {
          content: "</ul>";
        }
        li::before {
          content: "<li>";
        }
        li::after {
          content: "</li>";
        }
        ol::before {
          content: "<ol>";
        }
        ol::after {
          content: "</ol>";
        }
        span::before {
          content: "<span>";
        }
        span::after {
          content: "</span>";
        }
        summary::before {
          content: "<summary>";
        }
        summary::after {
          content: "</summary>";
        }
        details::before {
          content: "<details>";
        }
        details::after {
          content: "</details>";
        }
      </style>
    </details>

    <p>
      Let's also make it so that whenever our cursor is over a summary tag, it is a pointer, and we'll also indent
      things by 4 characters (4 chars).
    </p>

    <style>
      summary {
        cursor: pointer;
        margin: 1ch 4ch;
      }
    </style>

    <p>
      Some elements are a little trickier because they have attributes. Attributes are special variables or settings
      that HTML elements can have. Consider, for example, the &lt;a&gt; or ⚓️ (anchor), which often has a
      <code>href</code> attribute. We <em>need</em> that attribute, including its value, to be visible. This is done
      like so:
    </p>

    <style style="null">
      a[href]::before {
        content: "<a href='" attr(href) "'>";
      }

      /* we need to do this also with our style attributes */
      p[style]::before {
        content: "< style='" attr(style) '">"; }
    </style>
    <p style="--p: 1rem">
      The <code>attr()</code> function, see
      <a href="https://developer.mozilla.org/docs/Web/CSS/attr">mozilla docs</a> is a nifty trick, "supported" since CSS
      2.
    </p>
    <p>
      A surprisingly troublesome set of tags are any that don't close. Two examples of these non-closing tags are &lt;
      br&gt; and &lt; img&gt; . While we can make our &lt; br&gt; s visible(on most browsers) by adding empty content,
      this isn't the case with images now.
    </p>
    <style>
      /* This doesn't work on Safari */
      br {
        content: "";
        margin: 0;
      }

      br::after {
        content: "<br>";
        margin-top: -1em;
        white-space: pre;
      }

      /* TODO ...figure out how to have imgs show thier src ;) */

      img::before {
        content: "<img src='" attr(src) "'>";
      }
      img::after {
      }

      img {
        margin: auto !important;
        image-rendering: crisp-edges;
      }
    </style>

    <p>TODO: Add a more fun yet brutalist image or edit the image so it's more fun.<br /></p>
    <p>
      &nbsp;Another special element is "style" itself, which must include an escape character to avoid being taken
      literally. Here is the styling code and a little tweak to keep our closing style tags from being indented.
    </p>

    <style>
      style::before {
        content: "<style>";
      }
      style::after {
        content: "<\/style>";
        margin-left: -3ch;
      }

      /* While we are at it, let's have a little
         fun and style our style elements, giving
         them a background and a font */
      style {
        background: hsl(270, 63.5%, 50%, 20%);
        font-family: Geneva_9;
        font-size: 1.4em;
        overflow: auto;
      }
    </style>

    <aside>
      I think the need for escaping the closing tag (e.g. "\/style" instead of "/style") of our style element may be a
      parser bug. Browser developers might not have predicted that we would engage in the fun we're exploring here.
    </aside>

    <p>Along with this, we will expose any script tags and ensure their content is pre-formated.</p>

    <style>
      script::before {
        content: "<script>";
      }
      script::after {
        content: "</script>";
        margin-left: -3.1ch;
      }

      /* Let's theme our script elements */
      script {
        background: hsl(210, 63.5%, 50%, 20%);
        font-family: Geneva_9;
        font-size: 1.4em;
        overflow: auto;
      }
    </style>

    <p>
      If we don't do a little more tweaking to our document's head element, our style and script tags are exposed but
      look messy. Their closing tag will be indented, unlike in our body. So we need to add a little more style to the
      head element to fix this.
    </p>

    <style>
      head script::after,
      head style::after {
        margin-left: 0;
      }

      /* We can reuse our a href technique to expose what
         scripts are sourced in the page */

      script[src]::before {
        content: "<script='" attr(src) "'>";
      }

      p[style]::before {
        content: "<p style'" attr(style) "'>";
      }

      /*  Oh, and we need links for external resources */

      link[href]::before {
        content: "<link='" attr(href) "'>";
      }
      link {
        overflow: auto;
      }
    </style>

    <a id="how_nav_works"></a>

    <p>You might be wondering about that menu at the top of our page.&nbsp;</p>
    <p>
      Here's how it works. First, we use the "position: sticky" style to allow it to stick to the top of our page once
      we scroll to it. With it stuck to the top of our viewport, it stays there unless we scroll above where we loaded
      it (just after we opened our body element).&nbsp;
    </p>
    <p>As we want things to stay tidy in our menu, we'll hide the hrefs from our anchors.</p>

    <style>
      nav {
        position: sticky;
        top: 1;
        background: white;
        padding: 0.2em;
        text-align: center;
      }
      /* This will hide the hrefs of our navigation links */
      nav a[href]::before {
        content: "<a>";
      }

      /*. At the same time, we'll deal with our block quotes */
      blockquote::after {
        margin-left: -4ch;
      }
    </style>

    <p>
      To reduce the visual weight of the before and after pseudo-elements, we can give them a soft purple color and
      mostly hide them until we focus on them.:
    </p>

    <style>
      *::after,
      *::before {
        color: hsl(270, 63.5%, 50%, 20%);
        line-height: 0.7;
        transition: all 0.3s ease;
      }
      *:hover::after,
      *:hover::before,
      a::after,
      a::before {
        color: hsl(270, 63.5%, 50%, 80%);
      }
    </style>

    <p>
      Finally, I believe brutalist design, even when applied to truly naked brutal HTML Quines, is about function, not
      deliberate ugliness; I'd like to apply two humble style sets that improve the readability of this "brutiful"
      stack.
    </p>

    <style>
      /* 101 Startr Bytes of Style */
      html {
        max-width: 80ch;
        padding: 2ch;
        margin: auto;
        color: hsl(270, 0%, 0%, 90%) !important;
        font-size: 1.4em;
      }

      /* Hover over link, Style and Script elements to enjoy */
      link,
      script,
      style {
        transition: all 0.3s ease;
        opacity: 20%;
        max-height: 24rem;
      }
      script:hover,
      style:hover {
        opacity: 100%;
      }
      /* Fix for nav flicker  */
      nav {
        z-index: 1000;
      }
    </style>

    <p>
      &nbsp;The first is our 101 Startr Bytes of Style. We apply it as the base style to our whole html to give things a
      clean, modern feel. The second is a little bit of transition magic. It tones down the look of elements we wouldn't
      normally see unless we hover over them.
    </p>

    <p>
      One last thing. Although this idea has bounced around in my head for a decade, the thing that reminded me to pipe
      it into a file was seeing this piece of "Code as Art" from Geoff Huntley:
      <a href="https://noyaml.com/">no yaml</a>. Bring back the world's weird web.
    </p>

    <p>Kind regards</p>
    <p>
      <i>P.S.</i>&nbsp;Our saving and editing features are powered by JavaScript. The following script is used to save
      the DOM as an HTML file and to toggle all text nodes' "contentEditable" attribute.<br />
      The attribute "contentEditable" is a special one that allows us to edit the text of any element.
    </p>
    <details>
      <summary>The script is as follows👇. We've wrapped it in a details element for brevity.</summary>

      <script>
        // Function to delete script elements with src="/.11ty/reload-client.js"
        ///This is here to help with local 11nty dev

        function deleteReloadClientScripts() {
          document.querySelectorAll('script[src="/.11ty/reload-client.js"]').forEach(function (item) {
            item.remove();
          });
        }

        // Function to save the DOM as an HTML file
        function saveDOMAsHTML() {
          // Turn off editing so we don't lock it on
          turnOffAllTextEditable();

          // Turn off all draggable elements
          turnOffDraggableElements();

          // Call the function to delete the script elements
          deleteReloadClientScripts();

          // Get the current title and make it filesafe
          const fileSafeTitle = () =>
            document.title
              .replace(/[^\w\s]/g, "")
              .trim()
              .replace(/\s+/g, "-");
          const htmlContent = document.documentElement.outerHTML;

          // Create a Blob with the HTML content
          const blob = new Blob([htmlContent], { type: "text/html" });

          // Create a temporary URL to the Blob
          const url = URL.createObjectURL(blob);

          // Create a link element to trigger the download
          const a = document.createElement("a");
          a.href = url;
          a.download = fileSafeTitle() + ".html";

          // Trigger a click event on the link to start the download
          a.click();

          // Clean up by revoking the Blob URL
          URL.revokeObjectURL(url);
        }

        let isEditable = false;

        function turnOffAllTextEditable() {
          const textNodes = getTextNodes(document);
          textNodes.forEach((node) => {
            node.parentElement.removeAttribute("contentEditable");
          });
          isEditable = false;
          // set text of anchor #edit to "Stop Editing" to reflect state
          document.getElementById("edit").innerText = "Edit";
        }

        function toggleAllTextEditable() {
          const textNodes = getTextNodes(document);
          isEditable = !isEditable;
          // set text of anchor #edit to "Edit" or "Stop Editing" to reflect state
          textNodes.forEach((node) => {
            node.parentElement.contentEditable = isEditable;
          });
          document.getElementById("edit").innerText = isEditable ? "Stop Editing" : "Edit";
        }
        function getTextNodes(element) {
          const textNodes = [];
          function extractTextNodes(node) {
            if (node.nodeType === Node.TEXT_NODE) {
              textNodes.push(node);
            } else {
              for (const childNode of node.childNodes) {
                extractTextNodes(childNode);
              }
            }
          }
          extractTextNodes(element);
          return textNodes;
        }

        document.body.addEventListener("paste", function (e) {
          e.preventDefault();

          // Get the pasted text
          const clipboardData = e.clipboardData || window.clipboardData;
          const pastedText = clipboardData.getData("text/plain");

          // Filter out properties that don't start with "--"
          const filteredText = pastedText.replace(/(--[\w-]+:[^;]+;)/g, "");

          // Insert the filtered text into the body's contentEditable
          document.execCommand("insertText", false, filteredText);
        });

        // Define a debounce function
        function debounce(func, wait) {
          let timeout;
          return function (...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
          };
        }

        // Drag and Drop
        var isDragMode = false;
        var draggedElement = null;
        var placeholder = document.createElement("section");
        var lastTarget = null;

        placeholder.style.border = "3px dashed #0099FF"; // Placeholder styling
        placeholder.style.height = "1px"; // Set a default height, adjust as needed
        // set a negative margin to compensate for the additional height
        placeholder.style.marginBottom = "-0.2rem";
        placeholder.style.display = "block";

        function toggleDraggableElements() {
          isDragMode = !isDragMode;
          var elementsToToggle = document.querySelectorAll(
            "img, p, ol, ul, li, blockquote, h1, h2, h3, h4, h5, h6, pre, code, a, em, strong, div, article, summary, details, nav, aside, span, script, style"
          );
          elementsToToggle.forEach(function (element) {
            element.setAttribute("draggable", isDragMode);
          });
        }

        function turnOffDraggableElements() {
          isDragMode = false;
          // set text of anchor #toggleDrag to "Drag" to reflect state
          document.getElementById("toggleDrag").innerText = "Drag";
          //remove .removeAttribute('draggable') for any elements that have it
          // select by attribute
          var elementsToToggle = document.querySelectorAll("[draggable]");
          elementsToToggle.forEach(function (element) {
            element.removeAttribute("draggable");
          });
        }

        function handleDragStart(event) {
          if (!isDragMode) {
            event.preventDefault();
            return;
          }
          draggedElement = event.target;
        }

        function handleDragOver(event) {
          if (!isDragMode || !draggedElement) {
            event.preventDefault();
            return;
          }
          event.preventDefault();
          var dropTarget = event.target;

          // Get the previous sibling of the drop target
          var previousSibling = dropTarget.previousElementSibling;

          // Only move the placeholder if it's not already in the correct position
          if (previousSibling !== placeholder) {
            dropTarget.insertAdjacentElement("beforebegin", placeholder);
          }
        }

        function handleDrop(event) {
          if (!isDragMode || !draggedElement) {
            event.preventDefault();
            return;
          }
          event.preventDefault();

          requestAnimationFrame(() => {
            placeholder.replaceWith(draggedElement);
            draggedElement = null; // Reset the draggedElement variable
          });
        }

        function handleMouseOver(event) {
          if (isDragMode) {
            //event.target.style.outline = '2px solid #0099FF';  Blue outline
          }
        }

        function handleMouseOut(event) {
          if (isDragMode) {
            event.target.style.outline = ""; // Remove outline
          }
        }

        var toggleDragButton = document.getElementById("toggleDrag");
        toggleDragButton.addEventListener("click", function () {
          toggleDraggableElements();
          toggleDragButton.textContent = isDragMode ? "Stop Drag" : "Drag";
        });

        document.addEventListener("dragstart", handleDragStart);
        document.addEventListener("dragover", handleDragOver);
        document.addEventListener("drop", handleDrop);
        document.addEventListener("mouseover", handleMouseOver);
        document.addEventListener("mouseout", handleMouseOut);

        // Add a listener for the "dblclick" event
        document.addEventListener("dblclick", function (event) {
          var target = event.target;
          var style = target.getAttribute("style");
          var prompt = document.getElementById("prompt");
          prompt.value = style;

          // open prompt_wrapper
          var promptWrapper = document.getElementById("prompt_wrapper");
          promptWrapper.style.display = "block";

          // focus on prompt
          prompt.focus();

          // add a listener for the "input" event
          prompt.addEventListener("input", function (event) {
            var newStyle = prompt.value;

            if (newStyle) {
              target.setAttribute("style", newStyle);
            } /* else {
              target.removeAttribute("style");
            }*/
          });
          // Intercept the "submit" event and hide the prompt_wrapper
          promptWrapper.addEventListener("submit", function (event) {
            event.preventDefault();
            promptWrapper.style.display = "none";
            target = "none";
          });
          // tear down and clean up make sure that the next double click doesn't
          // use the same newStyle
          prompt.addEventListener("blur", function (event) {
            promptWrapper.style.display = "none";
            target = "none";
          });
        });
      </script>
    </details>

    <p style="null">
      <i>P.P.S.</i>&nbsp;If you want to see the source of this page, prefix the URL with "view-source:" and you'll see
      the source. You can do this on any page!
    </p>

    <section style="display: none" id="prompt_wrapper">
      <form>
        <input
          id="prompt"
          name="prompt"
          placeholder="Type utility shorthand (e.g., --m for margin)"
          style="--pos: fixed; --bottom: 1rem; --maxw: 47rem; --fs: 1rem; --lh: 1.5"
          autocomplete="off"
        />
        <pre
          id="customSuggestions"
          style="
            --d: block;
            --pos: fixed;
            --radius: 0.2rem;
            --bottom: 2.4rem;
            --w: 47rem;
            --fs: 1rem;
            --lh: 1.5;
            --overflow-y: auto;
            --p: 0.6rem;
            --bg: rgb(159, 79, 139);
            --c: white;
          "
        >

    Utilities start with --, end with a ;
</pre
        >
      </form>
    </section>

    <script>
      const utilities = {
        m: "margin: eg. --m:1rem;",
        p: "padding: eg. --p:1rem;",
        c: "color: eg. --c:red;",
        ta: "text-align: eg. --ta:center;",
        fw: "font-weight: eg. --fw:bold;",
        td: "text-decoration: eg. --td:underline;",
        bg: "background: eg. --bg:lightblue;",
        shadow: "startr.style's --shadow helper eg. --shadow:10;",
        w: "width: eg. --w:40ch;",
        h: "height: eg. --h:10ch;",
      };

      const inputPrompt = document.getElementById("prompt");
      const customSuggestions = document.getElementById("customSuggestions");

      // Function to update suggestions based on the filter
      function updateSuggestions(filter) {
        customSuggestions.textContent = ""; // Clear existing suggestions first

        if (!filter) {
          // If no filter, add all utilities as suggestions
          Object.keys(utilities).forEach((key) => {
            customSuggestions.textContent += `--${key} (${utilities[key]})\n`;
          });
        } else {
          // If there is a colon, only show exact matches
          if (filter.includes(":")) {
            const exactKey = filter.split(":")[0];
            if (utilities.hasOwnProperty(exactKey)) {
              var textContent = `--${exactKey} (${utilities[exactKey]})\n`;
              // prefix textContent var with newline char
              textContent = "\n" + textContent;
              customSuggestions.textContent = textContent;
            }
          } else {
            // Otherwise, filter the utilities based on the input and add them to suggestions
            const filteredKeys = Object.keys(utilities).filter((key) => key.startsWith(filter));
            filteredKeys.forEach((key) => {
              var textContent = `--${key} (${utilities[key]})\n`;
              // prefix textContent var with newline char
              textContent = "\n" + textContent;
              customSuggestions.textContent = textContent;
            });
          }
        }
      }

      inputPrompt.addEventListener("input", function (e) {
        const text = e.target.value;
        const entries = text.split(";"); // Split by semicolon to process each style separately
        const lastEntry = entries[entries.length - 1].trim(); // Get the last entry after the most recent semicolon

        // Reset the suggestions if the last character is a semicolon
        if (text.charAt(text.length - 1) === ";") {
          updateSuggestions("");
        } else if (lastEntry.startsWith("--")) {
          // If the last entry starts with --, update suggestions based on the filter
          const colonIndex = lastEntry.indexOf(":");
          if (colonIndex !== -1) {
            updateSuggestions(lastEntry.slice(2, colonIndex + 1).trim()); // Include the colon in the filter
          } else {
            updateSuggestions(lastEntry.slice(2).trim());
          }
        }
      });

      // don't show the wrapper on load
      //document.getElementById("prompt_wrapper").style.display = "block";
    </script>
    <h2 style="--ta: center" id="discover">Discover limitless possibilities</h2>
    <p style="--ta: center">
      Explore our lab of resources and experiment with the endless possibilities of Startr Style.
    </p>
    <p style="--ta: center;--c: aliceblue"><a onclick="window.location.href = '/'" style="--c: lightblue">Made with Startr.Style.</a> Enjoy our related creations:<br>
    <a onclick="window.location.href = '/brutalism'" style="--c: lightblue">Brutalism</a> ·
    <a onclick="window.location.href = '/modernism'" style="--c: lightblue">Modernism</a> ·
    <a onclick="null" style="--c: aliceblue">Minimalism</a> ·
    <a onclick="null" style="--c: aliceblue">Skeuomorphism</a> ·
    <a onclick="null" style="--c: aliceblue">Neumorphism</a> ·
    <a onclick="window.location.href = '/experimentalisim'" onclick="null" style="--c: lightblue">More</a>
  </p>
  </body>
</html>
