<html><head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://raw.githack.com/opencoca/system7.css/main/style.css">
<title>A brutalist HTML Quine â€“ It is what it is</title> 

</head>
<body>
    <nav>
      <a id="quine" href="#quine">Quine</a>
      <a href="#how it works">How</a>
      <a href="#how_nav_works">Nav</a>
      <a id="save" href="data:text, To save enable javascript." onclick="saveDOMAsHTML();return false;">Save</a>
      <a id="edit" href="data:text, To edit enable javascript." onclick="toggleAllTextEditable();return false;">Edit</a>
    </nav>

    <h1>This page is a, truly open, brutalist html quine...</h1>
    


    <p>
      I love to tweak and hack technology in creative ways.
      <br>
      We don't need to break things. 
      <br>
      Let's focus on bending the rules without breaking the rules.</p>

    <p>I've always loved creating things. As a child I started first with Basic, Hypercard, C, Pascal and VB. As I got older I moved to PHP, then Python, and creating some amazing things like <a href="https://etsy.com/">Etsy</a>. These days I focus on <a href="https://robotinacan.com/">Robot in a Can</a> and other projects.</p> 

    <p>I love to create things that are useful and beautiful. Things that inspire others to create are the most powerful and rewarding to build.<br>I love to create things that are fun and sillyâ€“ things that are weird and wonderful.<br>I love create things that are useful beautiful yet exposed and raw. Things that are brutally functional and feel best to me.</p>

    <p>To these ends this project is inspired by my reflecting on life and reading GÃ¶del, Escher Bach and most importantly talking with friends and family. The code inspiration <a href="https://github.com/secretGeek/">secretGeek</a>  and <a href="https://sr.ht/~sforman">my close friend Simon Forman</a>.
    </p>

    <p>The Computer Science world of&nbsp; code is filled with examples of amazing people stretching the rules, blowing past expectations. People using technology in new and fabulous ways.<br>I love the concept of&nbsp;<a href="http://wiki.secretgeek.net/quine">quines </a>. Quines are programs
      which output their own source code.</p>
      
    <p>If code is life, life is a Quine! As we build new things...they build more.</p>


    <blockquote>
      Another common theme in Brutalist designs is the exposure of the
      building's functions.
    </blockquote>

    <p>
      ...the tendency to <strong>make the internal external </strong> , and reveal the secrets of the building, in a somehow.... brutally beautiful -<em>brutaful</em> way.
    </p>

    <p>
      A similarly intriguing idea which has fallen into disuse is the idea of
      <a href="https://en.wikipedia.org/wiki/Naked_objects">naked objects</a>,
      wherein:
    </p>

    <blockquote>
      The user interface should be a direct representation 
      of the domain objects.
    </blockquote>

    <p>
      Putting all this together I decided to make this: a truly naked, brutalist html
      page; a page that is itself a quine; a page that is a<em>brutaful quine.</em></p>

    <p>
      How to view<a href="view-source:#This won't work on it's own.">the source</a>
      of this page? prefix the url with "view-source:" and you'll see the source of this page. Infact you
      can do this on any page. 
    </p>
    <a id="#how it works"></a>
    <h2>How it works.</h2>

    <p>
      Did you know that the rules of html and css allow us to make
      <strong>every</strong> element visible, even elements like 'title' or
      'style' or 'script', that are normally hidden from view? <br>Those are just
      elements like any other.<br>You can expose them <strong>all</strong> like so:
    </p>

    <style>
      * { display:block; }
    </style>

    <p>
      With that snippet of code (which is <strong>not</strong> a snippet of
      code, but an <strong>actual</strong> style block itself!) you can now see
      every element of this page, including that style block, the html and title
      tags, etc.
    </p>

    <p>
      It does have one downside: every element on the page is now a "block"
      element, even some which should be "inline", such as "code" and "anchor"
      elements. We can correct this like so:
    </p>

    <style>
      a,code,em,strong {display:inline}
    </style>

    <p>
      To give the code a more 'view source' feel, I've also applied
      <code>monospace</code> fonts, and a generally simple and consistent style
      to all elements, using a "*" selector, like so:
    </p>

    <style>
      *{ font-family:Monospace; margin:1.5em 0; padding:0; text-decoration:none}
    </style>

    <p>So far I've put style declarations all on one line, because ordinary
      html refuses to treat line breaks as "br" tags. But there is a way
      to make line-breaks display as line-breaks, and that is with this
      piece of styling:
    </p>

    <style>
      style, script {
        white-space: pre;
      }
      blockquote{
       white-space: pre-wrap;
      }

      p{
        word-break: break-word
      }
    </style>

    <h2>Make the internal external.</h2>

    <p>The next trick is to make the internal external. We can start by 
      ensuring that the tags themselves, such as paragraph tags, are 
      exposed in their stark, brutal, beauty:
    </p>

    <style>
      p::before {
        content:'<p>'
      }
      p::after {
        content:'</p>'
      }
    </style>

    <p>That works for "p" elements, but do we need to have custom styling for
      <strong>every</strong> element? If there was a way to output the "name" of
      a tag in html, then we could reduce all of the necessary style rules above
      to something like:
    </p>

    <blockquote>
      *::before {'&lt;'name()'&gt;'}
    </blockquote>

    <p>And...</p>

    <blockquote>
      *::after { '&lt;'name()'&gt;' }
    </blockquote>

    <p>But alas there is no "name()" function (yet!). So we are forced to
      generate a chunk of style information like this ðŸ‘‡</p>

    <details>
  <summary><p>It's a lot of repetitive code so I wrapped it in a details element. Feel free to click read all the lines of repetitive yet essential style code...
    </p></summary>

    <style>

      html::before {content:'<html>'}
      html::after {content:'</html>'}
      head::before {content:'<head>'}
      head::after {content:'</head>'}
      title::before {content:'<title>'}
      title::after {content:'</title>'}
      body::before {content:'<body>'}
      body::after {content:'</body>'}
      h1::before {content:'<h1>'}
      h1::after {content:'</h1>'}
      h2::before {content:'<h2>'}
      h2::after {content:'</h2>'}
      p::before {content:'<p>'}
      p::after {content:'</p>'}
      pre::before {content:'<pre>'}
      pre::after {content:'</pre>'}
      code::before {content:'<code>'}
      code::after {content:'</code>'}
      a::before {content:'<a>'}
      a::after {content:'</a>'}
      img::before {content: '<img>'}
      aside::before {content:'<aside>'}
      aside::after {content:'</aside>'}
      blockquote::before {content:'<blockquote>'}
      blockquote::after {content:'</blockquote>'}
      em::before {content:'<em>'}
      em::after {content:'</em>'}
      strong::before {content:'<strong>'}
      strong::after {content:'</strong>'}
      div::before {content:'<div>'}
      div::after {content:'</div>'}
      article::before {content:'<article>'}
      article::after {content:'</article>'}
      nav::before {content:'<nav>'}
      nav::after {content:'</nav>'}
      ul::before {content:'<ul>'}
      ul::after {content:'</ul>'}
      li::before {content:'<li>'}
      li::after {content:'</li>'}
      ol::before {content:'<ol>'}
      ol::after {content:'</ol>'}
      span::before {content:'<span>'}
      span::after {content:'</span>'}
      summary::before {content:'<summary>'}
      summary::after {content:'</summary>'}
      details::before {content:'<details>'}
      details::after {content:'</details>'}
    </style></details>

    <p>Let's also make it so that whenever over a summary tag our cursor is a pointer and we'll also indent thing by 4 chars.
    </p>

    <style>
      summary {cursor:pointer;
              margin: 1ch 4ch;}
    </style>

    <p>Some elements are a little trickier because they have attributes. Consider
      for example the "anchor" which often has a <code>href</code> attribute. We
      <em>need</em> that attribute to be visible, including its value. This is
      done like so:
    </p>

    <style>
      a[href]::before {content: "<a href='" attr(href) "'>"}
    </style>

    <p>
      The <code>attr()</code> function, see
      <a href="https://developer.mozilla.org/docs/Web/CSS/attr">mozilla docs</a>
      is a nifty trick, "supported" since CSS 2.
    </p>

    <p>A surprisingly troublesome set of tags are any that don't close. br and img for example. While we can get our &lt;br&gt;s to be processed by adding empty content this isn't the case with images at this time.</p>
      <style>
      br {
          content: "";
          margin: 0
      }

      br::after {
          content: "<br>";
          margin-top: -1em;
          white-space: pre;
      }
      
      /* TODO ...figure out how to have imgs work ;) */
      img { margin: auto !important; 
            content: "" !important}

      img::before {
          content: "<img src='" attr(src) "'>"
      }
      img::after {}

    </style><p>
      <a href="https://en.wikipedia.org/wiki/File:The_Earth_seen_from_Apollo_17.jpg">
      <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/The_Earth_seen_from_Apollo_17.jpg/220px-The_Earth_seen_from_Apollo_17.jpg" decoding="async" width="220" height="220">
      <br>The Earth seen from Apollo as an example img</a></p>
      <p>Another other element that is special is 
      "style" itself, which has to include an escape character to avoid 
      being taken literally. Her'e that along with a little tweak 
      to keep our closing style tags from being indented.</p>

    <style>
      style::before {content:'<style>'}
      style::after  {content:'<\/style>'; 
                     margin-left: -3ch}
      /* While we are at it let's have a little fun and style our style elements */
      style {
        background: hsl(270, 63.5%, 50%, 20% );
        font-family: Geneva_9;
        font-size: 1.4em;
        overflow: auto;
      }
    </style>

    <aside>I like to think that may be a parser 
      bug created by browser developers who did not suspect that people 
      would engage in such an atrocity.
    </aside>

    <p>Along with this we expose any script 
      tags and make sure that their
      content is pre-formated.
    </p>

    <style>
      script::before {content:'<script>'}
      script::after  {content:'</script>'; 
                      margin-left: -3.1ch}
      /* N along with the style let's theme our script elements */
      script {
        background: hsl(210, 63.5%, 50%, 20% );
        font-family: Geneva_9;
        font-size: 1.4em;
        overflow-y: auto;
      }
    </style>

    <p>&nbsp;On top of this if we don't do
      a little more tweaking the head the style and script tags are 
      exposed, but they look messy. Their closing tags are indented 
      when unlike in our body they shouldn't be. So we just need to 
      add a little style to the head element to fix this.</p>

    <style>
      head script::after, head style::after {margin-left: 0}
      /* Let's reuse our a href technique to expose what 
         scripts are sourced in our page */
      script[src]::before {content: "<script='" attr(src) "'>"}
      /*                                 */
      link[href]::before {content: "<link='" attr(href) "'>"}
    </style>
    
    <a id="how_nav_works"></a>

    <p>
      Let us simplify navigation formating by also applying our pre-formatting to our 
      nav element. At the same time we can expose positioning of it and we'll make sure that the nav element's closing tag is not indented.</p>

    <style>
      nav{padding: 0.2em;
          position: sticky;
          top:1;
          background: white}
      nav a[href]::before{content: '<a>'}

      /*. At the same time we'll dea; with our block quotes */
      blockquote::after{
      margin-left: -4ch
      }
    </style>

    <p>To reduce the visual weight of the before and after pseudo
      elements we can give them a soft purple color and a reduced line-height:</p>

    <style>
      *::before,*::after {
        color:hsl(270, 63.5%, 50%, 60% );
        line-height:0.8
      }
    </style>
    
    <p>
      Finally, I believe brutalist design, even when applied to truly
      naked brutal html quines, is about function, not about deliberate
      ugliness, I'd like to apply two humble stylestets that improve the
      readability of this brutiful stack.
    </p>

    <style>
     /* 101 Startr Bytes of Style */ 
     html {
        max-width:80ch;
        padding:2ch;
        margin:auto;
        color:hsl(270, 0%, 0%, 90%) !important;
        font-size:1.4em;
      } /**/
      /* Hover over Style and Scripts to enjoy */
      style, script{ 
        transition: opacity 0.3s ease;
        opacity: 20%;
      }
      style:hover, script:hover{
        opacity: 100%;
      }
      /* Fix for nav flicker  */
      nav {z-index:1000}
    </style>

    <p>&nbsp;The first is our 101 Startr Bytes of Style. We apply it as the base style to our whole html to give things a clean modern feel. The second is a little bit of transition magic. It tones down the look of elements we wouldn't normally see unless we hover on them.</p>

    <p>
      One last thing. Although this idea has bounced around in my head for a
      decade, the thing that reminded me to pipe it into a file was seeing this
      piece of "Code as Art" from Geoff Huntley:
      <a href="https://noyaml.com/">no yaml</a>. Bring back the world weird web.
    </p>

    <p>Kind regards</p>
    <p>p.s.
      <a href=".">source code here</a>
    </p>
      

    <script>
      // Function to save the DOM as an HTML file
      function saveDOMAsHTML() {
        // Turn off editing so we don't lock it on
        turnOffAllTextEditable();
        //get our current title and make it filesafe
        const fileSafeTitle = () => document.title.replace(/[^\w\s]/g, '')
                                        .trim().replace(/\s+/g, '-');
        const htmlContent = document.documentElement.outerHTML;
        // Create a Blob with the HTML content
        const blob = new Blob([htmlContent], { type: 'text/html' });
        // Create a temporary URL to the Blob
        const url = URL.createObjectURL(blob);
        // Create a link element to trigger the download
        const a = document.createElement('a');
        a.href = url;
        a.download = fileSafeTitle() +'.html';
        // Trigger a click event on the link to start the download
        a.click();
        // Clean up by revoking the Blob URL
        URL.revokeObjectURL(url);
      }

      let isEditable = false;

      function turnOffAllTextEditable() {
        const textNodes = getTextNodes(document);
        textNodes.forEach((node) => {
          node.parentElement.removeAttribute('contentEditable'); 
        });
        isEditable = false;
        // set text of anchor #edit to "Stop Editing" to reflect state
        document.getElementById('edit').innerText = 'Edit';
      }

      function toggleAllTextEditable() {
        const textNodes = getTextNodes(document);
        isEditable = !isEditable;
        // set text of anchor #edit to "Edit" or "Stop Editing" to reflect state
        textNodes.forEach((node) => {
          node.parentElement.contentEditable = isEditable;
        });
        document.getElementById('edit').innerText = isEditable ? 'Stop Editing' : 'Edit';
      }
      function getTextNodes(element) {
        const textNodes = [];
        function extractTextNodes(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            textNodes.push(node);
          } else {
            for (const childNode of node.childNodes) {
              extractTextNodes(childNode);
            }
          }
        }
        extractTextNodes(element);
        return textNodes;
      }
    </script>

</body></html>